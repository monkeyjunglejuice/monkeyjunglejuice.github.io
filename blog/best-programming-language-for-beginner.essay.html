<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-03-25 Sat 10:19 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Which Programming Language should I learn first?</title>
<meta name="author" content="Dan Dee" />
<meta name="description" content="How to pick your first programming language to learn coding" />
<meta name="keywords" content="learn programming, learn to code, programming languages, best programming language" />
<meta name="generator" content="Org Mode" />
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://wa.skred.net/; connect-src https://wa.skred.net/; img-src 'self' https://*; media-src 'self' https://*;">
<link rel="stylesheet" href="/static/normalize.css" type="text/css">
<link rel="stylesheet" href="/static/org.css" type="text/css">
<link rel="stylesheet" href="/static/style.css" type="text/css">
<link rel="stylesheet" href="/static/fonts/cormorant/fonts.css" type="text/css">
<link rel="stylesheet" href="/static/fonts/gentium-basic/fonts.css" type="text/css">
<link rel="stylesheet" href="/static/fonts/gentium-plus/fonts.css" type="text/css">
<link rel="stylesheet" href="/static/fonts/mononoki/fonts.css" type="text/css">
<link rel="icon" type="image/svg+xml" href="/static/monkeyjunglejuice.svg">
<link rel="apple-touch-icon" href="/static/monkeyjunglejuice-icon180.png">
<script defer src="/static/head.js"></script>
<link rel="canonical" href="https://monkeyjunglejuice.github.io/blog/best-programming-language-for-beginner.essay.html">
</head>
<body>
<div id="preamble" class="status">
<nav id="nav-primary"><a id="site-name" href="/index.html">MonkeyJungleJuice</a> <a id="github" href="https://github.com/monkeyjunglejuice">Github</a></nav>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Which Programming Language should I learn first?</h1>
<p class="subtitle" role="doc-subtitle">The Right Tool for the Job</p>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org984d2d2">What is this about?</a></li>
<li><a href="#orgd7ef037">The hard Part</a></li>
<li><a href="#org2453f10">What do You want to do?</a></li>
<li><a href="#orgd1f7e87">What makes a Programming Language beginner-friendly?</a>
<ul>
<li><a href="#orgff60761">Available Learning Material</a></li>
<li><a href="#orga491c5b">Syntax and Readability</a></li>
<li><a href="#org4d71a42">Expressive Power</a></li>
<li><a href="#org2ed058d">Usability and Programming Environment</a></li>
<li><a href="#org23f484e">Implementation Details</a></li>
<li><a href="#org7f36869">Popularity and Commmunity</a></li>
<li><a href="#org6c0cba6">Which Programming Language will be in high Demand</a></li>
<li><a href="#org366f5d9">Maturity</a></li>
<li><a href="#orgbf19b4d">What kind of Animal are you?</a></li>
</ul>
</li>
<li><a href="#org8521ff5">Choose your Poison</a>
<ul>
<li><a href="#orgacd748b">ANSI C as a first Programming Language</a></li>
<li><a href="#org6b4d740">Lua as a first Programming Language</a></li>
<li><a href="#org5fe3c95">Clojure as a first Programming Language</a></li>
<li><a href="#org001414e">Common Lisp as a first Programming Language</a></li>
<li><a href="#org476ed7e">Scheme or Racket as a first Programming Language</a></li>
<li><a href="#org0b496bf">Erlang or Elixir as a first Programming Language</a></li>
<li><a href="#org4452f2c">JavaScript as a first Programming Language</a></li>
<li><a href="#org2aa7919">Elm as a first Programming Language</a></li>
<li><a href="#org1212b0a">Haskell as a first Programming Language</a></li>
<li><a href="#orgf7ff25c">OCaml as a first Programming Language</a></li>
<li><a href="#org3711d1e">Python as a first Programming Language</a></li>
<li><a href="#org656b9e7">Julia as a first Programming Language</a></li>
</ul>
</li>
<li><a href="#orgfd6c020">Mkay, but which one?</a>
<ul>
<li><a href="#org1ea9b3b">The 3 best Programming Languages to learn Programming</a></li>
<li><a href="#org0d428ec">My personal Choice (C&rsquo;mon eat the damn Dog Food already!)</a></li>
</ul>
</li>
</ul>
</div>
</nav>

<div id="outline-container-org984d2d2" class="outline-2">
<h2 id="org984d2d2">What is this about?</h2>
<div class="outline-text-2" id="text-org984d2d2">
<p>
I&rsquo;m going to explain what I think is important for a first programming language from a beginner&rsquo;s perspective, clear up common misconceptions, review the most interesting languages with their pros/cons, and point to the best (free) learning resources and books.<br>
</p>

<blockquote cite="https://www.cs.utexas.edu/users/EWD/transcriptions/OtherDocs/Haskell.html">
<p>
»It is not only the violin that shapes the violinist, we are all shaped by the tools we train ourselves to use, and in this respect programming languages have a devious influence: they shape our thinking habits. This circumstance makes the choice of first programming language so important.«<br>
<cite>—<a href="https://www.cs.utexas.edu/users/EWD/transcriptions/OtherDocs/Haskell.html">Edsger W.Dijkstra</a></cite><br>
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgd7ef037" class="outline-2">
<h2 id="orgd7ef037">The hard Part</h2>
<div class="outline-text-2" id="text-orgd7ef037">
<p>
&ldquo;Learning a programming language&rdquo; applies foremost to programmers who already know how to program. For them, picking up a new language is possible within a couple of weeks (and for you too, once you&rsquo;ve gained some experience), and it does&rsquo;t matter really that much, which one – because the patterns how to accomplish most things are roughly overlapping.<br>
</p>

<p>
But if you start out, you don&rsquo;t need to just learn a programming language; as a beginner:<br>
</p>

<ol class="org-ol">
<li>You will have to learn <b>the language itself</b> with it&rsquo;s features, syntax, semantics and … warts. I would say this is the easiest thing of the three.<br></li>

<li>Then you want to learn <b>how to program</b>. It means learning how to analyze the problems you want to tackle, finding solutions and express them in algorithms and data structures, which is often not intuitive. For that, you&rsquo;re utilizing the various ways your programming langugage provides.<br></li>

<li>And there&rsquo;s <b>the technology part</b>, e. g. things like protocols, networking, cryptography, the platform or operating system, tooling and the language ecosystem. This is a vast ocean of knowledge, which requires some specialization.<br></li>
</ol>
</div>
</div>

<div id="outline-container-org2453f10" class="outline-2">
<h2 id="org2453f10">What do You want to do?</h2>
<div class="outline-text-2" id="text-org2453f10">
<p>
Is it your plan to become a software developer? Software is built in different domains – the most obvious within the web, is obviously the development of itself. But there are other areas than web frontend and web backend; like fintech, aircraft systems, robotics, telecom, water supply or internet of things. If you know exactly what your intentions are, you could start with a language of your specific field and go form there … or better not?<br>
</p>

<blockquote cite="https://www.cs.cornell.edu/courses/cs3110/2021sp/textbook/intro/pl.html" class="center">
<p>
&ldquo;It&rsquo;s crucial that you understand<br>
the principles behind programming<br>
that transcend the specifics<br>
of any specific language.&rdquo;<br>
<cite>—<a href="https://www.cs.cornell.edu/courses/cs3110/2021sp/textbook/intro/pl.html">Michael R. Clarkson</a></cite><br>
</p>
</blockquote>

<p>
The industry workhorse may probably not be the right fit, because it could be either highly specific and/or come with a lot of distracting things that don&rsquo;t matter for you right now. There&rsquo;s a reason one does not take the very first driving lessons on a bucket wheel excavator, but on a &#x2026; yes, a car. Or motorbike. If you pick the wrong one, you might not follow through.<br>
</p>

<p>
Life changes and programming is hard. So you should go with a language that&rsquo;s interesting to you – for whatever reason – and which is particularly suitable for learning, according to the criteria I lay out below. Read on, I will describe the most interesting languages further down.<br>
</p>

<p>
You may want to learn programming, even if you have no plans to become a part of the software producing workforce, like me. I&rsquo;ve worked quite a long time as a designer and in the online marketing industry, but have barely written any code at all, since there were always developers working alongside me and tasked with the wizardry.<br>
</p>

<p>
But I have always been interested in computer stuff, so I&rsquo;ve dabbled a lot with Linux, server administration and tweaking my configs as a means of procrastination. Real programming was the magical border I haven&rsquo;t crossed – until recently.<br>
</p>

<p>
For my part, I want a tool in which I can think, and I&rsquo;d like to be able to prototype an idea if I have one. Further, I think programming can help us tremendously to develop our minds. I must say that hated mathematics in school and have been really bad at it, but I&rsquo;m fascinated and eventually I want to know what is this all about.<br>
</p>

<blockquote class="center">
<p>
&ldquo;Life is short –<br>
pull down the curtain,<br>
cast some spells<br>
and wield some magic!&rdquo;<br>
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgd1f7e87" class="outline-2">
<h2 id="orgd1f7e87">What makes a Programming Language beginner-friendly?</h2>
<div class="outline-text-2" id="text-orgd1f7e87">
</div>
<div id="outline-container-orgff60761" class="outline-3">
<h3 id="orgff60761">Available Learning Material</h3>
<div class="outline-text-3" id="text-orgff60761">
<p>
For which programming language is the right learning material available? That point is huge!<br>
</p>

<p>
Most programming books or courses are not made for absolute beginners, but for programmers who want to <i>learn yet another language</i>. Remember, you want to <i>learn programming</i>, not just a language.<br>
</p>

<p>
&ldquo;Regular&rdquo; programming books are not &ldquo;too advanced&rdquo; to grasp; it&rsquo;s just that they <b>teach you the wrong things</b> instead of what you actually need to learn.<br>
</p>

<p>
Beware, there&rsquo;s a lot of crap out there. And the more popular a programming language, the more crap you&rsquo;ll run into. First, learn how to learn things by yourself (in a way that fits your personality). That skill is likely the most valuable one you&rsquo;ll ever develop.<br>
</p>

<p>
I recommend a textbook or e-textbook <b>with exercises</b> as your main forge of knowledge, because books are still the most accessible media – you can read a chapter even if you&rsquo;re queueing up somewhere, re-read each chapter until you got it, and <i>do the exercises</i>.<br>
</p>

<p>
Generally, I suggest to use material from university profs and/or other reputable personalities to make sure you adopt a well rounded foundation and good style, instead of jumping between random tutorials and wasting money on bootcamps.<br>
</p>

<p>
I&rsquo;ve linked the best books below. Most of them come for free! Get ready to dabble with your textbook for quite some time. <i>So you really want an enjoyable one!</i> The most recommended book may not neccesarily be the right one for you; individual taste matters a lot.<br>
</p>
</div>
</div>

<div id="outline-container-orga491c5b" class="outline-3">
<h3 id="orga491c5b">Syntax and Readability</h3>
<div class="outline-text-3" id="text-orga491c5b">
<p>
As a novice coder, you&rsquo;ll need enough brain capacity left to maintain focus on the concepts and what (your) code does, without the language getting in your way. So you want a simple syntax that&rsquo;s easy to pick up and remember. You don&rsquo;t want surprises and gotchas.<br>
</p>

<p>
Code is also more often read than written. A clean syntax enables the reader to understand what&rsquo;s going on in the program. Consistency enables you to derive further things from things you already have learned before and speeds up your learning process. <a href="https://cs.lmu.edu/~ray/notes/syntaxdesign/">Side read: Here&rsquo;s a nice overview that explains certain features a syntax can have, and how they affect the perception of code.</a><br>
</p>
</div>
</div>

<div id="outline-container-org4d71a42" class="outline-3">
<h3 id="org4d71a42">Expressive Power</h3>
<div class="outline-text-3" id="text-org4d71a42">
<p>
Expressivity means how simple it is to say certain things. There are a couple of factors who determine how expressive a programming language can be:<br>
</p>
</div>

<div id="outline-container-org02eabe2" class="outline-4">
<h4 id="org02eabe2">Expressions, Statements or a mix of both?</h4>
<div class="outline-text-4" id="text-org02eabe2">
<p>
One feature to look for is if a language has expressions only or if it mixes both expressions and statements.<br>
</p>

<p>
For sanity&rsquo;s sake, go for a language where <b>&ldquo;everything is an expression&rdquo;</b>. The reason for this is that expressions can be nested, so anything in the language can be combined with nearly anything else.<br>
</p>

<p>
Languages that have both expressions and statements tend to be clumsy, because some constructs are expressions, some are statements and both cannot be nested/combined as you see fit, so you run into silly barriers all the time and need to structure your code around those artificial limitations.<br>
</p>
</div>
</div>

<div id="outline-container-orga9977e2" class="outline-4">
<h4 id="orga9977e2">Low-level or High-level?</h4>
<div class="outline-text-4" id="text-orga9977e2">
<p>
Low-level does not mean &ldquo;worse&rdquo; or &ldquo;inferior&rdquo; than high-level – it just refers to the fact that computers are built in many layers on top of each other, and the levels close to the physical machine are called the &ldquo;low level&rdquo;. You could also call it &ldquo;foundation&rdquo;, if you prefer a less judgemental sounding term xP<br>
</p>

<p>
High-level languages tend to be more expressive than low-level languages, because with each layer up, the grade of <i>abstraction</i> increases and more powerful ways to express complex things come into play.<br>
</p>
</div>
</div>

<div id="outline-container-org5df981e" class="outline-4">
<h4 id="org5df981e">How simple is it to build Abstractions?</h4>
<div class="outline-text-4" id="text-org5df981e">
<p>
What is abstraction? It means hiding the foundational workings of the level(s) below (eg. the physical machine) so you don&rsquo;t have to deal with them directly and can focus on your problem/idea instead.<br>
</p>

<p>
An analogy: A console used to control the lightshow of a concert is an abstraction over fumbling with the electricity cables and tieing them together to make light bulbs glow in a certain order. Now think about doing the light show only by messing with the wires. This is dangerous and way harder (nearly impossible) than using the console. And so it is with programming, too.<br>
</p>
</div>
</div>

<div id="outline-container-orgf725bf7" class="outline-4">
<h4 id="orgf725bf7">Is it a wordy or concise Language?</h4>
<div class="outline-text-4" id="text-orgf725bf7">
<p>
Do you have to write a lot of boilerplate or repeat yourself? In most cases you want an expressive high-level language; not overly verbose but also not too terse, so there&rsquo;s just the right amount of redundancy left to keep it comprehensible. <a href="https://redmonk.com/dberkholz/2013/03/25/programming-languages-ranked-by-expressiveness/">Side-read: programming languages ranked by their expressiveness</a><br>
</p>
</div>
</div>
</div>

<div id="outline-container-org2ed058d" class="outline-3">
<h3 id="org2ed058d">Usability and Programming Environment</h3>
<div class="outline-text-3" id="text-org2ed058d">
<p>
Your language of choice ideally comes with tooling that&rsquo;s easy to use. &rsquo;Tooling&rsquo; includes things like editor support (syntax highlighting, &ldquo;jump-to-definition&rdquo;, looking up documentation), helpful (or at least comprehensible) error messages, and package management for libraries.<br>
</p>

<p>
Libraries are pieces of code written by other programmers that can be re-used, so a developer has less work and doesn&rsquo;t need to code everything from scratch. A good selection of libraries means basically &ldquo;less work&rdquo;. Having many libraries is desirable for industrial use, but it doesn&rsquo;t matter so much in the beginning. Many languages can also use libraries from other programming languages/ecosystems.<br>
</p>

<p>
Consider to pick a language that comes with a <i><a href="https://mikelevins.github.io/posts/2020-12-18-repl-driven/">REPL</a></i>, sometimes called <i>toplevel</i> to run single pieces of your code interactively. Well, nowadays many languages come with a &ldquo;REPL&rdquo;. But just a few languages enable true <i>interactive development</i>, a.k.a. <i>conversational programming</i>.<br>
</p>

<p>
Can you get started without huge ceremonies and fumbling for days?<br>
</p>
</div>
</div>

<div id="outline-container-org23f484e" class="outline-3">
<h3 id="org23f484e">Implementation Details</h3>
<div class="outline-text-3" id="text-org23f484e">
<p>
This is a thing that came to my mind reacently. I think it&rsquo;s tremendously helpful if you start with a programming language that is in large parts implemented in <i>itself</i> (and its libraries, too). This is often not the case, as many programming languages and their libraries are implemented in another, usually lower-level language.<br>
</p>

<p>
Why? As you advance in your programming endavour, it will deepen your understanding tremendously if you read a lot of ideomatic code – and for that, its really fantastic if you are able to peek into the source code of the built-in functions and modules of your programming language, finding those things written in the same language, not in some other language that&rsquo;s totally alien to you.<br>
</p>
</div>
</div>

<div id="outline-container-org7f36869" class="outline-3">
<h3 id="org7f36869">Popularity and Commmunity</h3>
<div class="outline-text-3" id="text-org7f36869">
<blockquote cite="http://www.paulgraham.com/iflisp.html">
<p>
&ldquo;Popularity is always self-perpetuating, but it&rsquo;s especially so in programming languages. More libraries get written for popular languages, which makes them still more popular. Programs often have to work with existing programs, and this is easier if they&rsquo;re written in the same language, so languages spread from program to program like a virus. And managers prefer popular languages, because they give them more leverage over developers, who can more easily be replaced.&rdquo;<br>
<cite>—<a href="http://www.paulgraham.com/iflisp.html">Paul Graham</a></cite><br>
</p>
</blockquote>

<p>
Popular means just that: popular. It does not imply &ldquo;technically superior&rdquo; or &ldquo;easy&rdquo; or &ldquo;getting a job&rdquo;: if everyone does it, why should they need you so badly? There&rsquo;ll always be someone better and cheaper. Also: Today&rsquo;s popular is tomorrow&rsquo;s most hated: Just two recent examples: Java and PHP. Popularity can diminish very quickly, so don&rsquo;t chase the hype (you&rsquo;re already too late anyway). <a href="https://cscalfani.medium.com/the-problem-with-popular-programming-languages-67faa14ac13b">Side read: The Problem with Popular Programming Languages</a><br>
</p>

<p>
Popular languages have some benefits though – for instance bigger ecosystems, which leads to many things built around the language to make the life of (experienced) programmers easier. Obviously, popular languages have also bigger communities.<br>
</p>

<p>
You don&rsquo;t need a huge community; smaller communities have their benefits, too. But it should be a welcoming one. Can you spot growth mindset and excitement?<br>
</p>

<p>
So, 700,000 people fullmoon rave or beach party with friends? Meh, forget both and practice some social distancing – it&rsquo;s <del>quite popular</del> in high demand right now!<br>
</p>
</div>
</div>

<div id="outline-container-org6c0cba6" class="outline-3">
<h3 id="org6c0cba6">Which Programming Language will be in high Demand</h3>
<div class="outline-text-3" id="text-org6c0cba6">
<p>
… in late autumn 2029 so I can get filthy rich coding it? Well, nobody knows and it doesn&rsquo;t matter. Why? <i>Because it&rsquo;s about learning to code</i> – which is a timeless skill – not about a particular language. These come and go.<br>
</p>

<p>
It&rsquo;s a bit like being able to ride a bicycle. Once you&rsquo;ve learned the underlying principle, you won&rsquo;t die instantly when you fall over, and it will not make much of a difference if you hop on Grandma&rsquo;s grinder or shred your neighbour&rsquo;s kid&rsquo;s tricycle, and you won&rsquo;t care if the current trend says in 10 years everyone will ride tiny mountain bikes with pink tyres.<br>
</p>
</div>

<div id="outline-container-org2a05764" class="outline-4">
<h4 id="org2a05764">But isn&rsquo;t there anything future proof? I&rsquo;m investing so much Time!</h4>
<div class="outline-text-4" id="text-org2a05764">
<p>
The best investment is in yourself: your abilities, probably the most important is <a href="https://www.youtube.com/watch?v=Kz_brQBl8xk">how to learn things on your own</a>.<br>
</p>

<p>
Language-feature-wise, there&rsquo;s in fact a thing that&rsquo;s getting more and more important, and that is <del>concurrency</del> <a href="https://medium.com/@itIsMadhavan/concurrency-vs-parallelism-a-brief-review-b337c8dac350">parallelism</a>. Most languages in use today have been developed years ago when <a href="https://en.wikipedia.org/wiki/Moore%27s_law">Moore&rsquo;s Law</a> was still valid. Back then, everyone expected single processors getting faster and faster, so it was perfectly fine to have languages to make programs running on a single processor/core, and no one really cared to build in parallelism features.<br>
</p>

<p>
But that is not any more. To keep up with the demands of modern applications, we have no other chance than to put more processors/cores into a computer, or to run the application distributed on multiple computers. To leverage the power of multi-core processors, we need to be able to program our software conveniently in a way to utilize all available cores. It may be a good idea to learn a programming language which is designed to build programs that run tasks in parallel.<br>
</p>
</div>
</div>
</div>

<div id="outline-container-org366f5d9" class="outline-3">
<h3 id="org366f5d9">Maturity</h3>
<div class="outline-text-3" id="text-org366f5d9">
<p>
While it may be tempting to begin with the new hyped language everyone is raving about, a mature programming language has the benefit of an organically grown user base, flaws ironed out, stuff being written about it, better tooling, etc.<br>
</p>

<p>
A mature language doesn&rsquo;t change every couple of months, so you can be sure to learn the &ldquo;right&rdquo; things – you don&rsquo;t have to worry if you&rsquo;re learning old stuff without knowing (looking at you, JavaScript).<br>
</p>

<p>
Which language has been around for quite a while, but implements modern, interesting and useful concepts that may be relevant in the future?<br>
</p>
</div>
</div>

<div id="outline-container-orgbf19b4d" class="outline-3">
<h3 id="orgbf19b4d">What kind of Animal are you?</h3>
<div class="outline-text-3" id="text-orgbf19b4d">
<p>
It seems there are two different groups of programmers. Those that see programming languages primarily as a means of production (category 1) and those who see it as instrument of human reason (categories 2 and 3):<br>
</p>

<ol class="org-ol">
<li><b>Pragmatic languages:</b> conservative, efficient, worse-is-better, boring.<br>
<i>&ldquo;A programming language is a tool to get the job done&rdquo;</i><br></li>
<li><b>Hackish languages:</b> multi-paradigm, anything goes, flexibility, unopinionated.<br>
<i>&ldquo;I pursue absolute freedom and like to explore the problem domain interactively&rdquo;</i><br></li>
<li><b>Constraining languages:</b> single-paradigm, protecting you from yourself, the-right-thing, opinionated.<br>
<i>&ldquo;I prefer one correct way according a fixed set of rules&rdquo;</i><br></li>
</ol>

<p>
Programming languages are created by different minds, within different eras, significantly influenced by fashion. One language may be a natural fit for a certain personality type, and a less fortunate choice for another. That even applies to programming itself – it&rsquo;s easier for some and harder for others (doesn&rsquo;t mean those are more stupid – ok, some really are).<br>
</p>
</div>
</div>
</div>

<div id="outline-container-org8521ff5" class="outline-2">
<h2 id="org8521ff5">Choose your Poison</h2>
<div class="outline-text-2" id="text-org8521ff5">
<p>
Some of them are actually better teaching languages, while others not so good and now I&rsquo;ll explain why. But be aware: that all of them suck in some way or another. By the way, the order of appearance is just for dramaturgical purposes and does not imply any <a href="#orgfd6c020">ranking</a>.<br>
</p>
</div>

<div id="outline-container-orgacd748b" class="outline-3">
<h3 id="orgacd748b">ANSI C as a first Programming Language</h3>
<div class="outline-text-3" id="text-orgacd748b">
<p>
Welcome to the low-level. Programs written in C tend to be much more performant than programs written in other languages. In other words, it is the fastest (practical) programming language. Performance-critical algorithms and other parts of applications are usually written in C; e. g. the Linux kernel, drivers, high-performance libraries, etc.<br>
</p>

<p>
There seems to be a tradeoff with programming languages:<br>
</p>
<ul class="org-ul">
<li>either high run-time performance (fast) plus low programmer productivity → longer development time<br></li>
<li>or lower run-time performance (slow) but higher programmer productivity → shorter development time<br></li>
</ul>

<p>
Development time (human) is more expensive than run-time time (computer), so mostly we agree on a slower programming language to minimize the human effort. However, since performance is a matter of the implementation and not the programming language per se, it is &#x2026; a myth. There are really fast high level programming languages coming close to C performance; <a href="#orgf7ff25c">OCaml</a> for instance.<br>
</p>

<p>
You may hear here and there that one must learn programming in C before even thinking about anything else – well, no. It is true that C code is in the underpinnings of almost every system nowadays, yes – because most programming languages are not written in themselves, but in C. But there is no need to learn C as your first language: Start only with C if your main interest lies in electronics and <a href="https://en.wikipedia.org/wiki/Systems_programming">systems programming</a>, or you have some other reason to work very close to the machine.<br>
</p>

<p>
If that is the case, and you wanna become that crazy hardware hacker, you may look into the <a href="https://www.arduino.cc/en/Guide/Introduction">Arduino electronics platform</a>, coming with the Arduino programming language (which is basically a subset of C). Don&rsquo;t confuse C with C++ (an extension to C, but huge and messy) or C# (a Microsoft thing). <i>Look for &ldquo;ANSI C&rdquo;</i>, the standard.<br>
</p>

<div class="box" id="orgbf2d026">
<ul class="org-ul">
<li><a href="https://learnxinyminutes.com/docs/c/">C code examples</a><br></li>
<li><a href="https://en.wikipedia.org/wiki/C_(programming_language)">Getting startet with C</a> or <a href="https://www.arduino.cc/en/Guide">Arduino</a><br></li>
<li>C programming book for beginners:<br>
<ul class="org-ul">
<li><a href="https://amzn.to/2XqQtag">The C Programming Language, 2nd Edition (paper/Kindle)</a><br></li>
<li><a href="https://amzn.to/3ht17Ej">Beginning C for Arduino, Second Edition (paper/Kindle)</a><br></li>
</ul></li>
</ul>

</div>
</div>
</div>

<div id="outline-container-org6b4d740" class="outline-3">
<h3 id="org6b4d740">Lua as a first Programming Language</h3>
<div class="outline-text-3" id="text-org6b4d740">
<p>
On the surface, Lua is quite similar to JavaScript – just without the ugly parts (more about that later). Lua is elegant, performant, carefully designed and consistent. Therefore it is super easy to learn for <del>Muggles</del> Non-programmers, and probably the &ldquo;easiest&rdquo; programming language listed here.<br>
</p>

<p>
Why is Lua an &ldquo;easy language&rdquo;? First, it is compact: There are not a lot of concepts or features to learn before you can do something meaningful. But then you can go on and combine the small set of building blocks with each other in many ways to implement more sophisticated things. Lua is probably the most simliar language to the Scheme programming language.<br>
</p>

<p>
Lua is used in many domains, especially in the game industry (e. g. World of Warcraft, Roblox). Lua can be a high-level counterpart to C and can be embedded into C program code, so that high-level program logic – like character behavior – can be scripted in Lua, while the other parts of the software in need for raw metal speed can be written in C or C++.<br>
</p>

<p>
It&rsquo;s straightforward to get started and build something with Lua: You might want to make your own 2D game with the Löve game engine, or you could use it to code native games and other apps for Android. There&rsquo;s a really nice IDE (&ldquo;Integrated Development Environment&rdquo;) for Lua programming, called &ldquo;ZeroBrane Studio&rdquo;; think of it as an extended editor especially for Lua.<br>
</p>

<p>
As far as I know, there are not many textbooks available, but you can use <i>the</i> book written by Lua&rsquo;s chief architect Roberto Ierusalimschy. And there&rsquo;s a wiki and many many user tutorials. Lua is primarily developed at the University of Rio de Janeiro (PUC-Rio). Once you&rsquo;ve committed to learn Lua, I recommend to buy the 4th edition to support the project.<br>
</p>

<div class="box" id="orgfbafe1b">
<ul class="org-ul">
<li><a href="https://learnxinyminutes.com/docs/lua/">Lua code examples</a><br></li>
<li><a href="https://www.lua.org/start.html">Getting started with Lua</a>, <a href="https://studio.zerobrane.com/">ZeroBrane Studio</a> and the <a href="https://love2d.org/">Löve game engine</a><br></li>
<li>Lua programming books for beginners:<br>
<ul class="org-ul">
<li><a href="https://www.lua.org/pil/contents.html">&ldquo;Programming in Lua 1st Edition&rdquo; (free online)</a><br></li>
<li><a href="https://store.feistyduck.com/products/programming-in-lua-fourth-edition-ebook">&ldquo;Programming in Lua 4th Edition&rdquo; (e-book)</a> | <a href="https://amzn.to/3clCl6k">Paper book</a><br></li>
</ul></li>
</ul>

</div>
</div>
</div>

<div id="outline-container-org5fe3c95" class="outline-3">
<h3 id="org5fe3c95">Clojure as a first Programming Language</h3>
<div class="outline-text-3" id="text-org5fe3c95">
<p>
As a total noob, I&rsquo;ve been looking for a language with a simple syntax, because who wants to run into syntax errors all the time? Clojure is a member of the <i>Lisp</i> family; those have in fact the cleanest syntax of all programming languages. Further, it seems to be an expressive general purpose language, and it&rsquo;s designed especially with concurrency in mind.<br>
</p>

<p>
The language is built on top of the Java platform. Software built on Java can run on almost any major operating system. Clojure can be used for different things, even for artsy stuff. Just as an example: <a href="https://overtone.github.io/">you can do live coding and make algorithmic music</a>, and there are things like algo-raves (yup, that exists …).<br>
</p>

<p>
It&rsquo;s also a practical language to build serious business software with, because it can use Java&rsquo;s enormous library ecosystem. And there&rsquo;s <a href="https://clojurescript.org/">ClojureScript</a>, a dialect of Clojure that compiles to JavaScript (so you won&rsquo;t have to write web apps in JavaScript).<br>
</p>

<p>
The language is a fresh take on Lisp and well designed. But there&rsquo;s also that Java underbelly who sticks out everywhere, coming with it&rsquo;s own terminology. And that&rsquo;s the drawback – you&rsquo;ll have to use Java stuff pretty soon and swallow the bleak Java speak <del>for a deeper understanding of Clojure</del> doing even basic things.<br>
</p>

<p>
If you want to try anyway, I recommend the book &ldquo;Clojure for the Brave and True&rdquo;; ok the &ldquo;humor&rdquo; gets annoying pretty quickly, but I had a good start with it and some enlightening moments. Well, the book convinced me also to take a look at Emacs, and I&rsquo;m a fanatic Emacs user since then.<br>
</p>

<div class="box" id="orge6851d5">
<ul class="org-ul">
<li><a href="https://learnxinyminutes.com/docs/clojure/">Clojure code examples</a><br></li>
<li><a href="https://clojure.org/guides/getting_started">Getting started with Clojure</a><br></li>
<li>Clojure programming book for beginners:<br>
<ul class="org-ul">
<li><a href="https://amzn.to/2ZZTL63">&ldquo;Clojure for the Brave and True&rdquo; (paper/Kindle)</a><br></li>
</ul></li>
</ul>

</div>
</div>
</div>

<div id="outline-container-org001414e" class="outline-3">
<h3 id="org001414e">Common Lisp as a first Programming Language</h3>
<div class="outline-text-3" id="text-org001414e">
<p>
My initial reason for me to use a programming language wasn&rsquo;t to write applications. Actually I wanted just a better calculator. A REPL makes a way better calculator than the silly concept of an interface resembling a physical pocket calculator with big buttons and a single line display.<br>
</p>

<p>
Well, here Lisp&rsquo;s functional notation felt really weird for doing arithmetik: Instead of <code>10 + 3 + 4 + 6 + 7</code> you write <code>(+ 10 3 4 6 7)</code>. There are no operators, everything it&rsquo;s basically function application. The uniform syntax is easy to pick up. And it doesn&rsquo;t get in your way, so you can concentrate on the things that really matter. This also makes a couple of things easier, for instance writing programs who write programs &#x2026; well, that&rsquo;s more advanced, but one of Lisp&rsquo;s many selling points: metaprogramming.<br>
</p>

<p>
I think the most compelling books and essays have been written on Lisp, and it has the best learning material I could find. Well, Lisp has been around for a while and is mature in any aspect.<br>
</p>

<p>
What really fascinates me, is that Lisp is no obscure magic box, where you write some keywords and then something underneath does some things and you don&rsquo;t know what and why. Lisp is different: everything is built from a few simple pieces. That makes it quite straightforward to paint a mental picture how it actually works. It&rsquo;s low-level and high-level at the same time. Mindblowing!<br>
</p>

<p>
The tooling is excellent and designed for interactive development. <b>There&rsquo;s a really nice <a href="https://apps.apple.com/us/app/cl-repl/id1511296102">App for iOS</a> and <a href="https://play.google.com/store/apps/details?id=org.eql5.android.repl">Android</a> called &ldquo;CL REPL&rdquo;.</b> You can use it to tinker around when ever you feel like <i>&ldquo;Damn, I wish I could write some Lisp right now!&rdquo;</i> You can. It&rsquo;s in fact a complete Common Lisp IDE with SLIME, the &ldquo;Superior Lisp Interaction Mode for Emacs&rdquo;.<br>
</p>

<p>
But usually you want it on your laptop. There are plugins for <a href="https://atom.io/packages/slima">Atom</a>, <a href="https://marketplace.visualstudio.com/items?itemName=ailisp.commonlisp-vscode">VSCode</a> and <a href="https://github.com/vlime/vlime">Vim</a>, although I recommend Emacs, which is straightforward to install <a href="https://portacle.github.io/">via Portacle</a>, a ready-made bundle coming with everything you need. If you don&rsquo;t know Emacs yet, do:<br>
</p>
<ol class="org-ol">
<li>Menu → &ldquo;Options&rdquo; → &ldquo;Use CUA keys&rdquo;<br></li>
<li>Menu → &ldquo;Options&rdquo; → &ldquo;Save options&rdquo;<br></li>
</ol>
<p>
– then copy &amp; paste works like everywhere else.<br>
</p>

<div class="box" id="org88af290">
<ul class="org-ul">
<li><a href="https://learnxinyminutes.com/docs/common-lisp/">Common Lisp code examples</a><br></li>
<li><a href="https://stevelosh.com/blog/2018/08/a-road-to-common-lisp/">Getting started with Common Lisp</a> and <a href="https://portacle.github.io/">the Portacle IDE</a><br></li>
<li>Lisp programming books for beginners:<br>
<ul class="org-ul">
<li><a href="https://amzn.to/308BHa0">&ldquo;Common Lisp: A Gentle Introduction to Symbolic Computation&rdquo; (paper/Kindle)</a> | <a href="https://www.cs.cmu.edu/~dst/LispBook/book.pdf">Free PDF</a><br></li>
<li><a href="https://amzn.to/3cwdnkW">&ldquo;Land of Lisp&rdquo; (paper/Kindle)</a><br></li>
</ul></li>
</ul>

</div>
</div>
</div>

<div id="outline-container-org476ed7e" class="outline-3">
<h3 id="org476ed7e">Scheme or Racket as a first Programming Language</h3>
<div class="outline-text-3" id="text-org476ed7e">
<p>
Pleasantly surprised by Clojure and Common Lisp, I&rsquo;ve looked up other languages from the Lisp family. Scheme is commonly recommended to beginners, especially for those who are interested in computer science. <a href="https://www.micahcantor.com/blog/why-learn-racket/">Why learn Racket? A student&rsquo;s perspective</a><br>
</p>

<p>
Like other Lisps, Scheme shares the same uniform list representation of source code (actually these are tree structures), which makes it easier to paint a mental picture of the program structure. There&rsquo;s no clutter, which I like.<br>
</p>

<p>
Scheme is opinionated in so far to stay unopinionated – meaning, it&rsquo;s a clean slate and people are eager to keep it that way. It is a minimalist language and often considered as the most elegant and consistent programming language; that makes it excellent for learning, reasoning about computation and to design algorithms, but not so much for cranking out some commercial business stuff app.<br>
</p>

<p>
Racket is a descendant of Scheme (it was called PLT Scheme before). But Racket is far from minimal. It has tons of features built in and you can think of Racket as &ldquo;Scheme with batteries included&rdquo;, and it is also platform for programming language research.<br>
</p>

<p>
Scheme can run on Racket, so even if you just want to learn the Scheme language, you can do it comfortably in Racket. That may sound a bit confusing, but it actually isn&rsquo;t. You&rsquo;ll see.<br>
</p>

<p>
Further, Racket emphasizes &ldquo;language oriented programming&rdquo;. It means you can design your own small (domain specific) programming languages for your particular application and then write your application in that language. But you don&rsquo;t have to – you can just use &ldquo;normal&rdquo; Racket like everyone else. So don&rsquo;t bother with that for now.<br>
</p>

<p>
The most recommended book on (functional) programming is the classic &ldquo;Structure and Interpretation of Computer Programs&rdquo;, abbreviatet &ldquo;SICP&rdquo;. It was written as an introduction for computer science students at MIT, using Scheme. But for me it was a bit too much as a very first book. But check it out anyway, it&rsquo;s really philosophical.<br>
</p>

<p>
I&rsquo;ve also began to read &ldquo;How to Design Programs&rdquo;, which is supposedly easier and often recommended to read before SICP, but found it a bit too earnest and dry. The other books are quite different. Personally I recommend &ldquo;Simply Scheme&rdquo;, &ldquo;The Little Schemer&rdquo; and &ldquo;Realm of Racket&rdquo;.<br>
</p>

<p>
You can get started very easily with Scheme and Racket – one single install and go, no matter if you are on Windows, Linux or Mac. You don&rsquo;t even have to be familiar with the command line, because it comes with DrRacket, a friendly and easy to use programming environment (IDE).<br>
</p>

<div class="box" id="orgb72fdfd">
<ul class="org-ul">
<li><a href="https://learnxinyminutes.com/docs/racket/">Racket code examples</a><br></li>
<li><a href="https://docs.racket-lang.org/quick/index.html">Getting started with Scheme or Racket and the DrRacket IDE</a><br></li>
<li>Scheme programming books for beginners:<br>
<ul class="org-ul">
<li><a href="https://people.eecs.berkeley.edu/~bh/simply-toc.html">&ldquo;Simply Scheme&rdquo; (free online)</a> | <a href="https://amzn.to/3cpR0gV">Paper book</a><br></li>
<li><a href="https://amzn.to/2XXHsEL">The little Schemer (Paper book)</a> | <a href="https://archive.org/download/Schemer/The%20Little%20Schemer.epub">Free PDF</a><br></li>
</ul></li>
<li>Racket programming books for beginners:<br>
<ul class="org-ul">
<li><a href="https://amzn.to/3gO29v8">&ldquo;Realm of Racket: Learn to Program, One Game at a Time!&rdquo; (paper/Kindle)</a><br></li>
<li><a href="https://amzn.to/2XRBWDr">&ldquo;How to Design Programs: An Introduction to Programming and Computing&rdquo; (paper/Kindle)</a> | <a href="https://htdp.org/2020-5-6/Book/index.html">Free online</a><br></li>
</ul></li>
<li>Introduction into computer science:<br>
<ul class="org-ul">
<li><a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">&ldquo;Structure and Interpretation of Computer Programs&rdquo; (free online)</a> | <a href="https://amzn.to/2ZZBS7f">Paper book</a><br></li>
</ul></li>
</ul>

</div>
</div>
</div>

<div id="outline-container-org0b496bf" class="outline-3">
<h3 id="org0b496bf">Erlang or Elixir as a first Programming Language</h3>
<div class="outline-text-3" id="text-org0b496bf">
<p>
The Erlang platform is building block of today&rsquo;s telecommunication networks. Your mobile provider&rsquo;s infrastructure runs likely on Erlang, and so does WhatsApp. Erlang is not just a programming language, but more like an operating system to write forever-running network applications. The whole point behind Erlang is to build fault-tolerant systems – it&rsquo;s all about error handling and staying online no matter what. <a href="https://adoptingerlang.org/docs/development/otp_high_level/">For more details on what the Erlang platform is, check this out</a>.<br>
</p>

<p>
To achive fault tolerance, Erlang leverages concurrency through an interesting concept, the <a href="https://www.brianstorti.com/the-actor-model/">actor model</a>. That makes Erlang platform a natural fit for decentralized computing, peer-to-peer networking, messaging apps and servers with thousands of simultaneous active users …<br>
</p>

<p>
Besides Erlang the platform there&rsquo;s Erlang the language, and there&rsquo;s Elixir. Those are two languages to write applications for the Erlang platform (there are even more, e.g. LFE &ldquo;Lisp Flavoured Erlang&rdquo;).<br>
</p>

<p>
<b>Erlang</b> (ERicsson LANGuage) is the original language. I like original Erlang syntax better than Elixir&rsquo;s, but the language itself has some quirks that make it quite inconvenient as a first language; e. g. there&rsquo;s no real interactive development since the Erlang shell is not a REPL and you cannot write code in the same way as you would do in a file.<br>
</p>

<p>
<b>Elixir</b> on the other hand is a new, alternative language with a Ruby-lookalike syntax (that&rsquo;s another programming language and was quite popular for some time, but now falling out of favor) plus some additional features like macros (Lisp-style metaprogramming).<br>
</p>

<p>
What I dislike about Elixir is that many constructs have 3-4 &ldquo;shorthands&rdquo; or special cases to write the same thing. It looks a bit like the language designers couldn&rsquo;t decide what to keep and what to throw out. All in all, the syntax looks a bit verbose and clumsy to me, e.g. a function definition in one line has a different notation than one that spans multiple lines, and another one if function appears within a module or not. What?<br>
</p>

<p>
Does it make sense to learn programming with Elixir? Most books only go through the language itself and it&rsquo;s features. There is not really learning material available for absolute beginners. The first one I listed below is quite short and covers some basics, but there&rsquo;s a gap between that and the second one, which requires some prior knowledge (but not much).<br>
</p>

<p>
Like with other hosted languages (Clojure on Java, Elm on JavaScript, …), the additional stuff coming with the Erlang platform may be a bit distracting. So if you want to learn Erlang or Elixir, you should have a particular reason to work with the Erlang platform, which isn&rsquo;t usually the case for a total beginner.<br>
</p>

<p>
Erlang or Elixir or both? You&rsquo;ll come pretty far with Elixir alone before you really need to dive into the platform technology. And once you are there, you&rsquo;ll have to develop an understanding of Erlang the language too, because the Erlang platform is explained in terms of Erlang the language, not in terms of Elixir.<br>
</p>

<div class="box" id="org1562951">
<ul class="org-ul">
<li><a href="https://learnxinyminutes.com/docs/erlang/">Erlang code examples</a><br></li>
<li><a href="https://learnxinyminutes.com/docs/elixir/">Elixir code examples</a><br></li>
<li><a href="https://elixir-lang.org/getting-started/introduction.html">Getting started with Elixir</a><br></li>
<li>Eixir programming books for beginners:<br>
<ul class="org-ul">
<li><a href="https://joyofelixir.com/toc.html">Joy of Elixir (free online)</a><br></li>
<li><a href="https://amzn.to/3p1gCH9">Learn Functional Programming with Elixir: New Foundations for a New World (paper/Kindle)</a><br></li>
</ul></li>
</ul>

</div>
</div>
</div>

<div id="outline-container-org4452f2c" class="outline-3">
<h3 id="org4452f2c">JavaScript as a first Programming Language</h3>
<div class="outline-text-3" id="text-org4452f2c">
<p>
With JavaScript, you can build all kind of things in the browser and show it to your internet friends, without having them to download or install anything. JavaScript is the only language browsers support directly, still – and that&rsquo;s why everybody and their dog&rsquo;s fleas are coding JavaScript.<br>
</p>

<p>
JavaScript <del>is</del> was an imperative language at the very heart, but you can write object-oriented and functional style too. JavaScript assimilates new features with each version and therefore it&rsquo;s getting bigger and bigger. Resistance is futile. Or is it?<br>
</p>

<p>
The language has good tooling and is easy to start with, and you may have heard &ldquo;all you need is a web browser and a text editor&rdquo;. Well, um, nope. That&rsquo;s not really the truth. Expect a lot exceptions, special cases and to work around the poor language design.<br>
</p>

<p>
You&rsquo;ll need to learn to avoid the pitfalls, and using a <a href="https://eslint.org/">linter</a> (that&rsquo;s a tool that checks your code and tells you where the problematic or deprecated parts are) is mandatory to prevent you from using probably harmful things and deprecated stuff.<br>
</p>

<p>
For me, it&rsquo;s a verbose frankenstein language that&rsquo;s a pain to read. Of course there are the usual suspects who disagree and even &ldquo;love&rdquo; JavaScript. These people either don&rsquo;t know any better, or suffer from a variant of the Stockholm Syndrome. Honestly, all of that doesn&rsquo;t make it a good choice for a first time programmer, but many start to learn programming with JavaScript, unfortunally.<br>
</p>

<p>
If you just would like to build web apps or browser games, you do have other choices (check out Elm down below) but eventually you need to know JavaScript – but maybe not necessarily learn it as your very first language.<br>
</p>

<div class="box" id="orgf098dea">
<ul class="org-ul">
<li><a href="https://learnxinyminutes.com/docs/javascript/">JavaScript code examples</a><br></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/JavaScript_basics">Getting started with JavaScript</a> and <a href="http://xahlee.info/js/javascript_basics.html">get a nice introduction with this tutorial</a><br></li>
<li>JavaScript programming book for beginners:<br>
<ul class="org-ul">
<li><a href="https://amzn.to/2U0p4K6">&ldquo;Eloquent JavaScript&rdquo; (paper/Kindle)</a> | <a href="https://eloquentjavascript.net">Free online</a><br></li>
</ul></li>
</ul>

</div>
</div>
</div>

<div id="outline-container-org2aa7919" class="outline-3">
<h3 id="org2aa7919">Elm as a first Programming Language</h3>
<div class="outline-text-3" id="text-org2aa7919">
<p>
Elm is a descendant of OCaml and Haskell that compiles to JavaScript: You write your website&rsquo;s code in Elm, and then the Elm compiler writes the JavaScript for you, so that your web browser can run it. If that sounds like it makes no sense, think about it this way: All programming languages compile down to another language on a lower level anyway, and those again and again, until your code&rsquo;s representation is only 11010101. Elm is just another layer on top.<br>
</p>

<p>
Why not writing JavaScript directly? Elm comes with a few interesting features: first and foremost a <i>static type system</i> (like OCaml), which helps you to feel (more) sure about the correctness of your code (think: less undiscovered bugs). And you don&rsquo;t have to deal with JavaScripts screwed type conversion. Secondly, Elm is a pure functional programming language: That makes it&rsquo;s easier to reason about what code actually does. And it comes with <i>immutable values</i>: ever writhed in disgust when you saw <code>x = x + 1</code>? Then Elm is for you (or other programming languages with immutable values).<br>
</p>

<p>
The Elm syntax is simple and the Elm compiler famous for its helpful error messages – like a built-in teacher who pushes you gently into the right direction on your pre-defined path to statically typed functional programming. And you will learn one way how to structure your application: &ldquo;The Elm Architecture&rdquo;.<br>
</p>

<p>
That&rsquo;s why I consider Elm a good fit for first-time coders, despite the fact that it&rsquo;s still a very young and very specifig language that runs exclusively in the browser. Which in turn means you&rsquo;ll need to know HTML and CSS, at least at a basic level. There is not so much literature out there about Elm, but it opens the door to other functional programming languages, like OCaml or Haskell.<br>
</p>

<p>
Elm comes with an easy installation and convenient tooling. The language is nicely designed as a whole piece, and it&rsquo;s quite opinionated: You&rsquo;ll need to do most things like intended by its creator, similar to Python. On the other hand that&rsquo;s one of the reasons why everything within the Elm ecosystem fits so well together.<br>
</p>

<p>
If I like Elm but it&rsquo;s a browser-only language, why not learn &ldquo;the real thing&rdquo; – Haskell or OCaml?<br>
</p>

<div class="box" id="orga38ae98">
<ul class="org-ul">
<li><a href="https://learnxinyminutes.com/docs/elm/">Elm code examples</a><br></li>
<li><a href="https://elm-lang.org/">Getting startet with Elm</a><br></li>
<li>Elm programming book for beginners:<br>
<ul class="org-ul">
<li><a href="https://elmprogramming.com/">&ldquo;Beginning Elm&rdquo; (free online)</a><br></li>
</ul></li>
</ul>

</div>
</div>
</div>

<div id="outline-container-org1212b0a" class="outline-3">
<h3 id="org1212b0a">Haskell as a first Programming Language</h3>
<div class="outline-text-3" id="text-org1212b0a">
<p>
Contrary to popular belief, basic Haskell is quite easy to pick up; that&rsquo;s even more true for a person who hasn&rsquo;t programmed before. It may be less straightforward for experienced developers, since they have preconceptions about programming.<br>
</p>

<p>
The Haskell programming language has not been developed with practicality in mind, rather to unify several research languages to explore <i>pure functional programming</i>, <i>lazy evaluation</i> and <i>static typing</i>. Haskell goes lengths to live up to that ideal, which leads to all kinds of complicated trickery.<br>
</p>

<p>
Basic Haskell has got a clean syntax, but it is terse and highly implicit. A lot is going on in a very small amount of code, and there are many ways to express one and the same thing. It&rsquo;s by no means a compact language. Haskellers … Haskelleers? Hasklers? Haskys??? Those who do the Haskell, you know – yes – tend to be clever, and generally like to use the advanced features the language has to offer.<br>
</p>

<p>
There is not &ldquo;one Haskell&rdquo; but numerous language extensions, and there are diverging opinions about which to use. It will get complicated very soon when you&rsquo;ll want to use libraries and read code others have fabricated - <a href="https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/">here&rsquo;s a disencouraging summary about the situation</a>.<br>
</p>

<p>
There&rsquo;s no clear path to get started with Haskell. Downloading the compiler and starting <i>ghci</i> (the &ldquo;REPL&rdquo;) to evaluate some expressions is no big deal of course, and to compiling some code neither.<br>
</p>

<p>
But if you go a bit further and want some more convenience and install libraries, there are a couple of different approaches which tooling set to use, and they overlap in functionality, and &#x2026; That&rsquo;s quite confusing.<br>
</p>

<p>
Not all hope is lost: If you want to get into functional programming, you&rsquo;re probably better off to start with OCaml (see below) which I think is a far better <i>first programming language</i>. You can still move on to Haskell later, if you feel like.<br>
</p>

<div class="box" id="org23af73c">
<ul class="org-ul">
<li><a href="https://learnxinyminutes.com/docs/haskell/">Haskell code examples</a><br></li>
<li><a href="https://docs.haskellstack.org/en/stable/README/">Getting started with Haskell (using Stack)</a><br></li>
<li>Haskell programming books for beginners:<br>
<ul class="org-ul">
<li><a href="https://amzn.to/2Uh00Pl">&ldquo;Haskell - the Craft of Functional Programming&rdquo; (paper/Kindle)</a><br></li>
<li><a href="https://haskellbook.com/img/sample.pdf">&ldquo;Haskell Programming from first Priniples&rdquo; (sample)</a><br></li>
</ul></li>
</ul>

</div>
</div>
</div>

<div id="outline-container-orgf7ff25c" class="outline-3">
<h3 id="orgf7ff25c">OCaml as a first Programming Language</h3>
<div class="outline-text-3" id="text-orgf7ff25c">
<p>
OCaml is in the same family as Elm and Haskell, but has less ideological ballast, is pragmatic, although still not as popular. How come? OCaml&rsquo;s main point of criticism in the past was its lack of practical tooling. But a lot has happened: Meanwhile, the editor support and interactive (REPL-driven) development experience in OCaml is op par with Haskell or even better.<br>
</p>

<p>
It think OCaml is long overdue for a rise in popularity: OCaml shines where speed and correct code are highly sought after; like financial technology, blockchain or compilers. <a href="https://ocaml.org/learn/companies.html">Some bigger companies</a> are heavily invested in OCaml. Many universities use OCaml to teach functional programming, so I found quiete a lot beginner-friendly learning material.<br>
</p>

<p>
OCaml syntax is very similar to Haskell&rsquo;s syntax, but leaves more room to breathe. It looks well structured, what makes it easy to recognize patterns in the code and know what&rsquo;s going on. I&rsquo;d say consistency and elegance are it&rsquo;s most remarkable attributes. So far, I&rsquo;ve written a couple trivial programs in it, and still had no WTF moments yet (and I&rsquo;m really sensitive to those kind of things).<br>
</p>

<p>
The language is heavily geared towards unix-like systems (Linux and MacOS), and has an automatic user-setup routine for Emacs and Vim. OCaml works also pretty well on Windows, but within the <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">WSL (Windows Subsystem for Linux)</a>. If you use WSL 1 You may run into a minor issue during the installing process because of WSL&rsquo;s limitations; anyway, <a href="https://github.com/ocaml/opam-repository/issues/12050#issuecomment-393478072">there&rsquo;s a workaround</a> for that. If you feel the urge to write native Windows apps, you might want to look into F# (F Sharp), which is essentially a modified OCaml clone by Microsoft that runs on the .NET platform.<br>
</p>

<div class="box" id="org7653f62">
<ul class="org-ul">
<li><a href="https://learnxinyminutes.com/docs/ocaml/">OCaml code examples</a><br></li>
<li><a href="https://ocaml.org/docs/up-and-running">Getting started with OCaml</a><br></li>
<li>OCaml programming books for beginners:<br>
<ul class="org-ul">
<li><a href="https://cs3110.github.io/textbook">OCaml Programming (free online with videos!!!)</a><br></li>
<li><a href="https://amzn.to/2XM04XW">OCaml from the Very Beginning (paper/Kindle)</a> | <a href="https://sites.fastspring.com/coherentgraphics/product/ocamlfromtheverybeginning">DRM-free PDF</a><br></li>
<li><a href="https://ocamlbook.org/">OCaml From the Ground Up (free online)</a><br></li>
</ul></li>
</ul>

</div>
</div>
</div>

<div id="outline-container-org3711d1e" class="outline-3">
<h3 id="org3711d1e">Python as a first Programming Language</h3>
<div class="outline-text-3" id="text-org3711d1e">
<p>
It is one of the most popular languages right now, and that&rsquo;s probably Python&rsquo;s biggest benefit. So if there&rsquo;s something programmable, like say, maybe an educational drone, then it has likely a Python interface.<br>
</p>

<p>
There are Python libraries for almost everything. Many of those libraries are actually written in other languages (e.g. C or C++) for performance reasons, because Python itself is the slowest of the languages listed here. It just happens that many libraries have a Python interface, that means they are made accessible from Python.<br>
</p>

<p>
The syntax looks clean and readable at a first glance, but is no hallmark of consistency. It&rsquo;s said to be an &ldquo;easy&rdquo; language, but I think that&rsquo;s just marketing. I find others actually better understandable. It&rsquo;s more like … well selected code examples look nice, and the onboarding process is made frictionless to shovel newcomers in.<br>
</p>

<p>
Python is highly opinionated: The creators encourage that certain things should (only) be done in a certain way – what they call &ldquo;pythonic&rdquo;. The opposite is &ldquo;unpythonic&rdquo;. &ldquo;To describe something as clever is not considered a compliment in the Python culture&rdquo;.<br>
</p>

<p>
I think Python is a dead end, even if it&rsquo;s popular right now, because it locks you into a narrow path (&ldquo;the pythonic way&rdquo;), and paints you in the object-oriented corner with all the complexity that comes with it, while making other paradigms (like functional programming) cumbersome/impossible.<br>
</p>

<p>
Beginners should not put blinkers on and march &rsquo;the pythonic way&rsquo;, but start with a language that opens the mind. Is Python a good first language? I considered to learn Python a couple of years ago, but after some research I found other languages far more elegant and comprehensible.<br>
</p>

<p>
If you want a powerful scripting language which is easier to learn, compact and highly performant, you may have fun with <a href="#org6b4d740">Lua</a>. And if popularity is still such a thing for you after <a href="#org7f36869">reading this</a>, you might be better off with <a href="#org4452f2c">JavaScript</a>.<br>
</p>

<div class="box" id="org3c3163d">
<ul class="org-ul">
<li><a href="https://learnxinyminutes.com/docs/python/">Python code examples</a><br></li>
<li><a href="https://www.python.org/about/gettingstarted/">Getting started with Python</a><br></li>
<li>Python programming book for beginners:<br>
<ul class="org-ul">
<li><a href="https://amzn.to/3tV2OkF">Learn Python 3 the Hard Way (paper/Kindle)</a> | <a href="https://learnpythonthehardway.org/python3/">Author&rsquo;s website</a><br></li>
<li><a href="https://amzn.to/3gPrLbf">Automate the Boring Stuff with Python (paper/Kindle)</a><br></li>
</ul></li>
</ul>

</div>
</div>
</div>

<div id="outline-container-org656b9e7" class="outline-3">
<h3 id="org656b9e7">Julia as a first Programming Language</h3>
<div class="outline-text-3" id="text-org656b9e7">
<p>
Julia is being developed as a pragmatic high performance vehicle for technical and scientific computing, as an alternative to Python, Fortran, R and other languages used in the field. I would say its not a language to build neither ready-to-ship software nor small programs, but more like a system to run your computing tasks in.<br>
</p>

<p>
It&rsquo;s still a young language, but eagerly promoted by a couple of organizations. So it looks like there&rsquo;s more of an ecosystem than you would expect for a language in that early state. The learning material is targeted for scientists who stand on the brink to make the switch. So for now, don&rsquo;t expect &ldquo;learn programming&rdquo; stuff for total beginners.<br>
</p>

<p>
Julia&rsquo;s REPL is quite powerful (maybe second to Common Lisp&rsquo;s REPL) and allows a high level of interactivity. The language looks friendly and easy to start with, and you should definitely check it out if you&rsquo;re a student and work in &ldquo;data science&rdquo;, statistics, numerical computing or want to plot some stuff (<a href="#org476ed7e">Racket</a> shines here, too).<br>
</p>

<div class="box" id="org2241693">
<ul class="org-ul">
<li><a href="https://learnxinyminutes.com/docs/julia/">Julia code examples</a><br></li>
<li><a href="https://en.wikibooks.org/wiki/Introducing_Julia/Getting_started">Getting started with Julia</a><br></li>
<li>Julia programming book for beginners:<br>
<ul class="org-ul">
<li><a href="https://amzn.to/381AhzH">&ldquo;Think Julia: How to Think Like a Computer Scientist&rdquo; (paper/Kindle)</a> | <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html">Free online</a><br></li>
</ul></li>
</ul>

</div>
</div>
</div>
</div>

<div id="outline-container-orgfd6c020" class="outline-2">
<h2 id="orgfd6c020">Mkay, but which one?</h2>
<div class="outline-text-2" id="text-orgfd6c020">
<p>
<b>Choose well, but don&rsquo;t obsess too much about it:</b> I&rsquo;ve already done that part for you, and it has been a pleasure of its own kind. You are going to learn a couple more programming languages after your first one, so it is not a lifetime decision, even if you feel like that now.<br>
</p>
</div>

<div id="outline-container-org1ea9b3b" class="outline-3">
<h3 id="org1ea9b3b">The 3 best Programming Languages to learn Programming</h3>
<div class="outline-text-3" id="text-org1ea9b3b">
<ol class="org-ol">
<li><a href="#org476ed7e"><b>Racket</b></a> has the lowest entry barrier if you have not touched any code yet, but is also the most feature rich. It can teach you all the mind exploding concepts, comes with educational books and exceptional documentation. It&rsquo;s also quite academic (oh, I said the A-word :P) and not used in industrial settings. But you can build shiny things with it, that is what counts.<br></li>

<li><a href="#orgf7ff25c"><b>OCaml</b></a> emphasizes functional programming but supports multiple paradigms, so it can give you a well-rounded education. It is a modern functional language used in academics and in the industry to build mission-critical software. Not sooo much hand-holding here, but a language without WTFs where just everything seems to make sense.<br></li>

<li><a href="#org6b4d740"><b>Lua</b></a> may not teach you all those fancy concepts like Racket and OCaml right upfront. But being minimalist <i>and</i> powerful, you will be able to start quite small and build on it while up in the air. Lua is practical: it has the smallest footprint, runs everywhere and is used for a wide spectrum of things.<br></li>
</ol>
</div>
</div>

<div id="outline-container-org0d428ec" class="outline-3">
<h3 id="org0d428ec">My personal Choice (C&rsquo;mon eat the damn Dog Food already!)</h3>
<div class="outline-text-3" id="text-org0d428ec">
<p>
When I was looking around for learning material, I found this one to be <a href="https://amzn.to/308BHa0">my favorite programming book</a>. I&rsquo;ve had a hard time choosing, and honestly I&rsquo;m still torn between <a href="#org001414e">Common Lisp</a>&rsquo;s &ldquo;code is data, data is code&rdquo; and interactive programming style vs. <a href="#orgf7ff25c">OCaml</a>&rsquo;s superior readability.<br>
</p>

<p>
Eventually I started with Common Lisp, <a href="learning-to-code-first-app-episode-1.tutorial.html">let&rsquo;s see how it goes</a>. I think the Lisp workflow fits pretty well, since I enjoy building things exploratively bottom-up. The interactivity offers something completely different from the write-compile-run-repeat cycle of most languages.<br>
</p>

<p>
Besides that: for me, being a Emacs user, it makes sense to learn Lisp, since Emacs itself is written in Lisp another dialect, but still of mutual benefit (<a href="https://hyperpolyglot.org/lisp">compare example code here</a>).<br>
</p>

<p>
<b>Which programming language are you going to learn now?</b><br>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="footer">Last updated: <span class="date">2023-03-21 Tue 21:02</span></p>
<script defer src="/static/foot.js"></script>
</div>
</body>
</html>
