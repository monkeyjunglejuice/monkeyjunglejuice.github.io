<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2025-12-03 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Let's code a GTK Theme Switcher for XFCE in OCaml</title>
<meta name="author" content="Dan Dee" />
<meta name="description" content="Writing a GTK Theme Switcher for XFCE4 to toggle light/dark mode via shortcut" />
<meta name="keywords" content="ocaml, dark mode, gtk, xfce, gtk theme, linux, tutorial, project idea, learn ocaml" />
<meta name="generator" content="Org Mode" />
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://wa.skred.net/; connect-src https://wa.skred.net/; style-src 'self' https://*; font-src 'self' https://*; img-src 'self' https://*; media-src 'self' https://*;">
<link rel="stylesheet" href="/static/normalize.css" type="text/css">
<link rel="stylesheet" href="/static/org.css" type="text/css">
<link rel="stylesheet" href="/static/style.css" type="text/css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cormorant:wght@300&family=Gentium+Plus:ital,wght@0,400;0,700;1,400;1,700&family=PT+Sans+Caption:wght@400;700&family=PT+Sans+Narrow:wght@400;700&family=PT+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/static/fonts/iosevka/fonts.css" type="text/css">
<link rel="icon" type="image/svg+xml" href="/static/monkeyjunglejuice.svg">
<link rel="apple-touch-icon" href="/static/monkeyjunglejuice-icon180.png">
<link rel="canonical" href="https://monkeyjunglejuice.github.io/blog/learn-ocaml-light-dark-theme-switcher-gtk.tutorial.html">
</head>
<body>
<div id="preamble" class="status">
<nav id="nav-primary"><a id="site-name" href="/index.html">MonkeyJungleJuice</a> <a id="index" href="/index.html">Index</a><a id="bio" href="/bio.html">Bio</a><a id="github" href="https://github.com/monkeyjunglejuice">Github</a></nav>
<div class="info"><time itemprop="dateModified" datetime="2025-03-24">Last updated: 2025-03-24</time></div>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Let&rsquo;s code a GTK Theme Switcher for XFCE in OCaml</h1>
<p class="subtitle" role="doc-subtitle">Code Walktrough – 1st Episode</p>
</header><nav class="pager" id="orgb320189">
<p>
This post is part of a miniseries:<br>
</p>
<ol class="org-ol">
<li><b><a href="learn-ocaml-light-dark-theme-switcher-gtk.tutorial.html">Let&rsquo;s Code a GTK Theme Switcher for XFCE in OCaml</a></b><br></li>
<li><a href="learn-ocaml-config-file-parsing-switch-gtk-theme.walktrough.html">Config File Parsing in OCaml</a><br></li>
</ol>
</nav>

<nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9968f4f">Toggle light/dark Mode in XFCE (and Gnome)</a></li>
<li><a href="#org3a56921">Gathering Information</a>
<ul>
<li><a href="#orgc85916d">Shell Commands to set dark/light Mode</a></li>
</ul>
</li>
<li><a href="#org7bfd457">Prerequisites</a></li>
<li><a href="#org65e430d">Features</a></li>
<li><a href="#orgdac8a4e">Where to begin?</a></li>
<li><a href="#orge511321">The »Get« Function</a>
<ul>
<li><a href="#org32bd0fd">Modeling Data Types</a></li>
<li><a href="#org70efd48">Testing the Function in the Toplevel (REPL)</a></li>
<li><a href="#orgaf23085">Remove superfluos Quotes from a String</a></li>
<li><a href="#orgdee51be">Putting the Function together</a></li>
</ul>
</li>
<li><a href="#orgf8e588e">The »Set« Function</a></li>
<li><a href="#org1141251">The »Toggle« Function</a></li>
<li><a href="#orgd0aa8b6">Paaartey! A working Prototype!</a></li>
</ul>
</div>
</nav>
<div id="outline-container-org9968f4f" class="outline-2">
<h2 id="org9968f4f"><a href="#org9968f4f">Toggle light/dark Mode in XFCE (and Gnome)</a></h2>
<div class="outline-text-2" id="text-org9968f4f">
<p>
I&rsquo;m using XFCE4 since a couple of years and despite newer desktop environments for Linux, I always went back to XFCE beause it&rsquo;s the least invasive and lets me do the things I want. Changing the XFWM window manager for XMonad or even EXWM? No problem.<br>
</p>

<p>
But XFCE lacks an easy way to quickly switch from a light theme to a dark mode and back via key shortcut.<br>
</p>

<p>
Normally, someone would come up with a shell script to do things like that, but I&rsquo;m about to learn OCaml anyway, so let&rsquo;s write that in OCaml.<br>
</p>
</div>
</div>
<div id="outline-container-org3a56921" class="outline-2">
<h2 id="org3a56921"><a href="#org3a56921">Gathering Information</a></h2>
<div class="outline-text-2" id="text-org3a56921">
<p>
One can select a GTK theme in XFCE with <code>xfce4-appearance-settings</code>. XFCE remembers what theme I&rsquo;ve set, so my first guess is that we&rsquo;ll have to find out how and where XFCE does this – in order to change it.<br>
</p>

<p>
Linux is quite simple as most user preferences are stored in &ldquo;config files&rdquo;, which are just plain text files located somewhere in <code>~/.config</code>. So we can probably do something like this:<br>
</p>

<ol class="org-ol">
<li>Find the config file where the information about the selected theme is stored<br></li>
<li>Change the information about the dark/light mode there<br></li>
<li>Tell XFCE to reload the config file in order apply the change immediately<br></li>
</ol>

<p>
Not so bad for a first guess, but the glorious <a href="https://wiki.archlinux.org/title/Dark_mode_switching#GTK">ArchLinux wiki has a better idea</a> about setting light or dark mode for GTK apps:<br>
</p>

<blockquote>
<p>
To change the light/dark mode, you have to change the used theme. Most themes do have a dark variant and those have by convention the suffix -dark. For example the default GTK theme Adwaita has the variant Adwaita-dark.<br>
</p>
</blockquote>

<p>
Further, the wiki tells us:<br>
</p>

<blockquote>
<p>
To switch themes instantly for running programs, either a daemon providing the xsettings spec or gsettings is required. For desktops running with Xorg, an xsettings daemon is needed. For desktops running with Wayland, gsettings is queried.<br>
</p>
</blockquote>

<p>
Mmmmkay, so the functionality already exists in XFCE4. And it&rsquo;s not about a config file to change, but speaking to daemons. You can issue those commands just straight from the command line (try it!):<br>
</p>
</div>
<div id="outline-container-orgc85916d" class="outline-3">
<h3 id="orgc85916d"><a href="#orgc85916d">Shell Commands to set dark/light Mode</a></h3>
<div class="outline-text-3" id="text-orgc85916d">
<p>
Under XFCE, you have to use the <a href="https://docs.xfce.org/xfce/xfconf/xfconf-query"><code>xfconf-query</code></a> utility to get/set themes<br>
&#x2013;&gt; We call this from now on <b>xsettings</b> backend<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Get the name of the currently active themes</label><pre class="src src-shell">xfconf-query -c xsettings -p /Net/ThemeName
xfconf-query -c xsettings -p /Net/IconThemeName
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>Set the dark UI theme and a dark icon theme</label><pre class="src src-shell">xfconf-query -c xsettings -p /Net/ThemeName -s "Adwaita-dark" &amp;&amp;
xfconf-query -c xsettings -p /Net/IconThemeName -s "Papirus-Dark"
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>Set the light UI theme and a light icon theme</label><pre class="src src-shell">xfconf-query -c xsettings -p /Net/ThemeName -s "Adwaita" &amp;&amp;
xfconf-query -c xsettings -p /Net/IconThemeName -s "Papirus-Light"
</pre>
</div>

<p>
And in GNOME there is the <a href="https://wiki.gnome.org/HowDoI/GSettings"><code>gsettings</code></a> utility (which you also have to use if you are running Wayland rather than Xorg)<br>
&#x2013;&gt; We refer to this as the <b>gsettings</b> backend.<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>Get the name of the currently active themes</label><pre class="src src-shell">gsettings get org.gnome.desktop.interface gtk-theme
gsettings get org.gnome.desktop.interface icon-theme
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>Set the dark UI theme and a dark icon theme</label><pre class="src src-shell">gsettings set org.gnome.desktop.interface gtk-theme "Adwaita-dark" &amp;&amp;
gsettings set org.gnome.desktop.interface icon-theme "Papirus-Dark"
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>Set the light UI theme and a light icon theme</label><pre class="src src-shell">gsettings set org.gnome.desktop.interface gtk-theme "Adwaita" &amp;&amp;
gsettings set org.gnome.desktop.interface icon-theme "Papirus-Light"
</pre>
</div>

<p>
<b>If you just landed here because you searched for how to set dark/light themes via commmand line or shortcut:</b><br>
The easiest solution for you is to define two <i>application shortcuts</i> via <code>xfce4-keyboard-settings</code>: the first shortcut to execute the commands to set your dark theme, and the second for your light theme – and you are done. Just copy &amp; paste the set commands above, either the <code>xsettings</code> variant or the <code>gsettings</code> variant.<br>
</p>

<p>
<b>To all others: We&rsquo;re doing real programming here!</b><br>
For the sake of learning, we&rsquo;ll just accept the little overhead. So this is going to be a wrapper utilizing the <code>xsettings</code> and <code>gsettings</code> backends to toggle between light and dark mode with one single shortcut, plus some other features.<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org7bfd457" class="outline-2">
<h2 id="org7bfd457"><a href="#org7bfd457">Prerequisites</a></h2>
<div class="outline-text-2" id="text-org7bfd457">
<p>
If you want to follow the walktrough, you&rsquo;ll need at least:<br>
</p>

<ul class="org-ul">
<li><b>opam</b> (the OCaml package manager) must be installed and configured<br></li>
<li>A computer running either Linux/Unix with XFCE or GNOME Desktop<br></li>
<li>A proper editor (e.g. Emacs, Vim or VS Code) with OCaml support<br></li>
<li>Very basic programming knowledge (what&rsquo;s a function, variable, etc.)<br></li>
</ul>
</div>
</div>
<div id="outline-container-org65e430d" class="outline-2">
<h2 id="org65e430d"><a href="#org65e430d">Features</a></h2>
<div class="outline-text-2" id="text-org65e430d">
<p>
What do we need our program to do? Let&rsquo;s make a quick list:<br>
</p>

<ul class="org-ul">
<li class="off">&#x2610; Determine the currently active GTK theme<br></li>
<li class="off">&#x2610; Toggle the UI (GTK) theme<br></li>
<li class="off">&#x2610; Change the icon theme accordingly<br></li>
<li class="off">&#x2610; Read the preferences from a config file:<br>
<ul class="org-ul">
<li class="off">&#x2610; … which backend to use (either xsettings or gsettings)<br></li>
<li class="off">&#x2610; … or check/select the available backend automatically<br></li>
<li class="off">&#x2610; … preferred dark/light UI themes<br></li>
<li class="off">&#x2610; … preferred dark/light icon themes<br></li>
</ul></li>
<li class="off">&#x2610; Write the initial config file if it doesn&rsquo;t yet exist<br></li>
<li class="off">&#x2610; Compile a standalone executable<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgdac8a4e" class="outline-2">
<h2 id="orgdac8a4e"><a href="#orgdac8a4e">Where to begin?</a></h2>
<div class="outline-text-2" id="text-orgdac8a4e">
<p>
<i>I would like to see the baby!</i> Alright, let&rsquo;s implement the core feature first: toggle between the light theme and the dark theme.<br>
</p>

<p>
When there&rsquo;s only <i>one</i> key combination to switch between light and dark theme, our programm has to make a decision: which theme to set when we press the key. Therefore, at some point our program needs to find out which theme is currently &ldquo;on&rdquo;. That&rsquo;s a start, eh?<br>
</p>
</div>
</div>
<div id="outline-container-orge511321" class="outline-2">
<h2 id="orge511321"><a href="#orge511321">The »Get« Function</a></h2>
<div class="outline-text-2" id="text-orge511321">
<p>
<b>Getting the name of the currently active theme</b><br>
</p>

<p>
Remember, we can find out what theme is currently active with the shell command we talked about before:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>Shell command</label><pre class="src src-shell">xfconf-query -c xsettings -p /Net/ThemeName
</pre>
</div>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>Output</label><pre class="src src-shell">Adwaita
</pre>
</div>

<p>
We have to execute the shell command from inside our program, and then capture the output of the shell command, so that our program can use this information internally to make a decision. In OCaml, we are doing things with <i>functions</i>. We can use the function <a href="https://www.ocaml.org/api/Unix.html#VALopen_process_in"><code>Unix.open_process_in</code></a> from OCaml&rsquo;s <i>Unix</i> module:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">Unix.open_process_in "xfconf-query -c xsettings -p /Net/ThemeName"
</pre>
</div>

<p>
This function opens an <code>in_channel</code>, but doesn&rsquo;t yet spit out the theme name; rather we have to get the theme name from that <code>in_channel</code>. We can use another function <a href="https://www.ocaml.org/api/Stdlib.html#VALinput_line"><code>input_line</code></a> that reads from the <code>in_channel</code> line by line (Each time <a href="https://www.ocaml.org/api/Stdlib.html#VALinput_line"><code>input_line</code></a> is applied, it returns the next line, until there is none left – but here we call it only once).<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">input_line (Unix.open_process_in "xfconf-query -c xsettings -p /Net/ThemeName")
</pre>
</div>

<p>
Look at the parenthesis: in OCaml we use the parens for grouping, like we do in maths. The parens ensure that the value of the inner function <code>(Unix.open_process_in "xfconf-query …")</code> is going to be computed first, and the resulting value is passed to the function <a href="https://www.ocaml.org/api/Stdlib.html#VALinput_line"><code>input_line</code></a>. So eventually, the two nested functions above will produce the output we&rsquo;re looking for:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">- : string = "Adwaita"
</pre>
</div>
</div>
<div id="outline-container-org32bd0fd" class="outline-3">
<h3 id="org32bd0fd"><a href="#org32bd0fd">Modeling Data Types</a></h3>
<div class="outline-text-3" id="text-org32bd0fd">
<p>
One more thing before we are going to implement the function: Let&rsquo;s write down what types of data we know of. Just because … we can. We could do without, but it may be of use later. So what do we know?<br>
</p>

<ul class="org-ul">
<li>We know we are going to use a <i>backend</i>, of which there are 2 variants: either <i>xsettings</i> or <i>gsettings</i><br></li>
<li>We&rsquo;re also going to deal with a variant of <i>widget</i> at a time: either <i>UI</i> themes or <i>icon</i> themes<br></li>
</ul>

<p>
We can write this in a formal way OCaml understands, and define types with the keyword <code>type</code>, the name of the type (a.k.a. <i>type constructor</i>; lowercase), and variants (a.k.a. <i>data constructors</i>; capitalised):<br>
</p>

<pre class="example" id="org4a8b38d">
type type_constructor = Data_construtor_1
                      | Data_constructor_2
                      | Data_constructor_n
</pre>

<p>
Here you go:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">type backend = Xsettings | Gsettings
type widget = Ui | Icon
</pre>
</div>

<p>
For now, the variants will serve as arguments to tell our function for which <i>&ldquo;type of backend&rdquo;</i> and which <i>&ldquo;type of widget&rdquo;</i> we&rsquo;re asking.<br>
</p>

<p>
So how could we express &ldquo;Use the <i>xsettings</i> backend to get the name of the <i>Ui theme</i> and return it&rdquo; in OCaml?<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">get_theme Xsettings Ui;;
</pre>
</div>

<p>
Until now, this does nothing of course. We&rsquo;ll have to give this expression a meaning first – we need to <i>implement</i> the function. Since there are 2 backends (<i>xsettings</i> and <i>gsettings</i>) with 2 widgets each (<i>UI theme</i> and <i>icon theme</i>), that makes 4 combinations how we can call the function:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">get_theme Xsettings Ui;;            (* 1st combination *)
get_theme Xsettings Icon;;          (* 2nd combination *)
get_theme Gsettings Ui;;            (* 3rd combination *)
get_theme Gsettings Icon;;          (* 4th combination *)
</pre>
</div>

<p>
Let&rsquo;s write down what should happen in each case: All we have to do now is just a little &ldquo;if this, than that&rdquo;. In OCaml, we have a sleek way to do such things, namely pattern matching. Here&rsquo;s the pattern matching syntax with 3 branches:<br>
</p>

<pre class="example" id="org549ead3">
match VALUE(S) with
| PATTERN_1 -&gt; EXPRESSION_1
| PATTERN_2 -&gt; EXPRESSION_2
| PATTERN_N -&gt; EXPRESSION_N
</pre>

<p>
When the function receives the arguments, those will be matched against the <i>pattern before the arrow</i>. If there is a match, the corresponding <i>expression after the arrow</i> will be triggered, and that&rsquo;s it. If there is no match, it&rsquo;s the turn of the next branch.<br>
</p>

<p>
In the first branch we can say:<br>
</p>

<p>
&ldquo;If the values for <code>backend</code> and <code>widget</code> match <code>Xsettings</code> and <code>Ui</code> -&gt; return the first line from the <code>in_channel</code> opened by the expression <code>(Unix.open_process_in ...</code> as a <i>string</i>, and stop here. If any of them doesn&rsquo;t match, do nothing but continue with the next branch.&rdquo;<br>
</p>

<p>
… and for all other branches accordingly:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let get_theme backend widget =
  match backend, widget with
  | Xsettings, Ui -&gt;                                    (* 1st branch *)
    input_line
      (Unix.open_process_in
         "xfconf-query -c xsettings -p /Net/ThemeName")
  | Xsettings, Icon -&gt;                                  (* 2nd branch *)
    input_line
      (Unix.open_process_in
         "xfconf-query -c xsettings -p /Net/IconThemeName")
  | Gsettings, Ui -&gt;                                    (* 3rd branch *)
    input_line
      (Unix.open_process_in
         "gsettings get org.gnome.desktop.interface gtk-theme")
  | Gsettings, Icon -&gt;                                  (* 4th branch *)
    input_line
      (Unix.open_process_in
         "gsettings get org.gnome.desktop.interface icon-theme")
</pre>
</div>

<p>
If we fail to handle all possible cases (e.g. we forget one branch/combination), the compiler warns us that the pattern matching is not exhaustive and which cases are unhandled and suggests potential solutions.<br>
</p>

<p>
<b>But how does the compiler know …?</b> Because we&rsquo;ve said so before:<br>
</p>
<div class="org-src-container">
<pre class="src src-ocaml">type backend = Xsettings | Gsettings
type widget = Ui | Icon
</pre>
</div>
</div>
</div>
<div id="outline-container-org70efd48" class="outline-3">
<h3 id="org70efd48"><a href="#org70efd48">Testing the Function in the Toplevel (REPL)</a></h3>
<div class="outline-text-3" id="text-org70efd48">
<p>
Let&rsquo;s see what happens when we call it with various arguments:<br>
</p>

<p>
<i>Side note: expressions in the toplevel end always with <code>;;</code> – that&rsquo;s how you can spot if an expression is meant to be evaluated in the toplevel.</i><br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>Toplevel input</label><pre class="src src-ocaml">get_theme Xsettings Ui;;
</pre>
</div>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span>Result</label><pre class="src src-ocaml">- : string = "Adwaita" (* &lt;-- Looks good … *)
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span>Toplevel input</label><pre class="src src-ocaml">get_theme Xsettings Icon;;
</pre>
</div>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 12: </span>Result</label><pre class="src src-ocaml">- : string = "Papirus-Light" (* &lt;-- Ok! *)
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 13: </span>Toplevel input</label><pre class="src src-ocaml">get_theme Gsettings Ui;;
</pre>
</div>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 14: </span>Result</label><pre class="src src-ocaml">- : string = "'Adwaita'" (* &lt;-- Yikes! What? *)
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 15: </span>Toplevel input</label><pre class="src src-ocaml">get_theme Gsettings Icon;;
</pre>
</div>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 16: </span>Result</label><pre class="src src-ocaml">- : string = "'Papirus-Light'" (* &lt;-- Nonono! make those quotes go away! *)
</pre>
</div>

<p>
Yeah you may have  guessed it – the <code>gsettings</code> shell command returns theme names wrapped in additional <code>'…'</code> single quotes, while <code>xfconf-query</code> does not. Nah, we don&rsquo;t want that. Should we get rid of them? Yeah probably. They suck.<br>
</p>
</div>
</div>
<div id="outline-container-orgaf23085" class="outline-3">
<h3 id="orgaf23085"><a href="#orgaf23085">Remove superfluos Quotes from a String</a></h3>
<div class="outline-text-3" id="text-orgaf23085">
<p>
We could just use a function to remove the first and last character no matter what, right? But it&rsquo;s good practise to <i>be specific</i>: We&rsquo;ll need a helper function that takes a string, looks if there are single quotes at the beginning and end, and returns another string with the same content but without the single quotes.<br>
</p>

<p>
Let&rsquo;s visit <a href="https://ocaml.org/api/">https://ocaml.org/api/</a> and check if the function we need is readily available in the OCaml library. At a glance we&rsquo;ll see there are two modules related to strings: <a href="https://ocaml.org/api/String.html">String</a> and <a href="https://ocaml.org/api/Str.html">Str</a>. There are in fact several functions we could use to achive the desired result.<br>
</p>
</div>
<div id="outline-container-orgf6ab125" class="outline-4">
<h4 id="orgf6ab125"><a href="#orgf6ab125">Regular Expressions to the Rescue</a></h4>
<div class="outline-text-4" id="text-orgf6ab125">
<p>
The <a href="https://ocaml.org/api/Str.html"><code>Str</code></a> module is what we are looking for, and I particularly like the function <a href="https://www.ocaml.org/api/Str.html#VALglobal_replace"><code>Str.global_replace</code></a>:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 17: </span>Type signature</label><pre class="src src-ocaml">val global_replace : regexp -&gt; string -&gt; string -&gt; string
</pre>
</div>

<p>
According to the <a href="https://ocaml.org/api/Str.html#VALglobal_replace">documentation</a>, the function wants the follwing arguments:<br>
</p>
<ul class="org-ul">
<li>a regular expression to describe what characters should be replaced<br></li>
<li>a template string that says what to put there instead<br></li>
<li>and the original string we&rsquo;d like to liberate from the single quotes<br></li>
</ul>

<p>
Ok, first we&rsquo;ll need the regex. There it is: <code>^'\|'$</code> it describes what to pay attention to: a &ldquo;string beginning with&rdquo; <code>^</code> one <code>'</code> &ldquo;or&rdquo; <code>|</code> one <code>'</code> &ldquo;at the end&rdquo; <code>$</code>.<br>
</p>

<p>
It took me a while to realize the regular expression we&rsquo;ll going to pass to the function is not just another string, but the function <a href="https://ocaml.org/api/Str.html#VALregexp"><code>Str.regexp</code></a> that takes a string containing the regular expression in order to &ldquo;compile&rdquo; it. Yeah that was quite confusing.<br>
</p>

<ul class="org-ul">
<li>we have the regular expression in parenthesis <code>()</code><br></li>
<li>the template is an empty string <code>""</code> (because we want to replace the sigle quotes with <i>nothing</i>)<br></li>
<li>and as the last argument, we&rsquo;ll pass our original string<br></li>
</ul>

<p>
Now we can test the function in in the toplevel like so:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">Str.global_replace (Str.regexp "^'\|'$") "" "'Freemee!'";;
</pre>
</div>

<p>
And? Works? Yes, but we&rsquo;re getting a <code>Warning 14 [illegal-backslash]: illegal backslash escape in string.</code><br>
</p>

<p>
The <a href="https://ocaml.org/api/Str.html#VALregexp">documentation</a> says, that the regex has to be written with double backslashes <code>^'\\|'$</code>, because within strings, the backslash has already a meaning as an escape character, e.g. for <code>\n</code> (new line) and others. Well well! So here&rsquo;s the final function to &ldquo;remove&rdquo; the single quotes:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">Str.global_replace (Str.regexp "^'\\|'$") "" "'Freemee!'";;
</pre>
</div>

<p>
To make it easier to refer to that function later, let&rsquo;s wrap it in a function and call it <code>clean</code>, so we don&rsquo;t have to type or copypasta the whole thing repeatedly if we&rsquo;re going to use that in more places:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let clean s =
  Str.global_replace (Str.regexp "^'\\|'$") "" s
</pre>
</div>

<p>
Now we can do just:<br>
</p>
<div class="org-src-container">
<pre class="src src-ocaml">clean "'Adwaita'";;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 18: </span>Result</label><pre class="src src-ocaml">- : string = "Adwaita"
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgdee51be" class="outline-3">
<h3 id="orgdee51be"><a href="#orgdee51be">Putting the Function together</a></h3>
<div class="outline-text-3" id="text-orgdee51be">
<p>
We can make the <code>clean</code> function available within our <code>get_theme</code> function via <code>let … in</code> syntax, and then apply it to the output of the <code>gsettings</code> shell commands … but you know what?<br>
</p>

<p>
What if, say, <code>xfconf-query</code> gets an update and suddenly spits out the theme names single-quoted, too? Or does something completly different? I mean, can we <i>trust</i> the output of another program?<br>
</p>

<p>
Nope, we actually can&rsquo;t. What we can do though, is validating and filtering input – being as specific as possible. So for here, let&rsquo;s apply the <code>clean</code> function to the results of all 4 branches at least, but leave it at that.<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let get_theme backend widget =
  let clean s =        (* we LET the helper function IN here *)
    Str.global_replace (Str.regexp "^'\\|'$") "" s in
  match backend, widget with
  | Xsettings, Ui -&gt;
    clean (input_line  (* &lt;-- we use it in the 1st branch *)
             (Unix.open_process_in
                "xfconf-query -c xsettings -p /Net/ThemeName"))
  | Xsettings, Icon -&gt;
    clean (input_line  (* &lt;-- and in the 2nd branch *)
             (Unix.open_process_in
                "xfconf-query -c xsettings -p /Net/IconThemeName"))
  | Gsettings, Ui -&gt;
    clean (input_line  (* &lt;-- in the 3rd branch *)
             (Unix.open_process_in
                "gsettings get org.gnome.desktop.interface gtk-theme"))
  | Gsettings, Icon -&gt;
    clean (input_line  (* &lt;-- and in the 4th branch, too *)
             (Unix.open_process_in
                "gsettings get org.gnome.desktop.interface icon-theme"))
</pre>
</div>

<p>
Yes, we&rsquo;ll have to group the expression beginning with <code>input_line …</code> in another set of parens, so that the <code>clean</code> function will be applied to the <i>result</i> of <a href="https://www.ocaml.org/api/Stdlib.html#VALinput_line"><code>input_line</code></a>.<br>
</p>
</div>
</div>
</div>
<div id="outline-container-orgf8e588e" class="outline-2">
<h2 id="orgf8e588e"><a href="#orgf8e588e">The »Set« Function</a></h2>
<div class="outline-text-2" id="text-orgf8e588e">
<p>
<b>Setting the GTK- and icon themes</b><br>
</p>

<p>
Once again we&rsquo;re about to wrap shell commands. The <code>set_theme</code> function is almost the same, so I&rsquo;ll make it short. We&rsquo;re going to use the types again to tell the function which backend to use, and if either the Ui theme or the Icon theme is going to be set. Additionally, we&rsquo;ll pass the theme name to the function as it will become part of the shell commands (via string concatenation through the <a href="https://www.ocaml.org/api/Stdlib.html#VAL(%5E)"><code>^</code></a> operator).<br>
</p>


<div class="org-src-container">
<pre class="src src-ocaml">let set_theme backend widget name =
  match backend, widget with
  | Xsettings, Ui -&gt;
    Unix.open_process
      ("xfconf-query -c xsettings -p /Net/ThemeName -s " ^ name)
  | Xsettings, Icon -&gt;
    Unix.open_process
      ("xfconf-query -c xsettings -p /Net/IconThemeName -s " ^ name)
  | Gsettings, Ui -&gt;
    Unix.open_process
      ("gsettings set org.gnome.desktop.interface gtk-theme " ^ name)
  | Gsettings, Icon -&gt;
    Unix.open_process
      ("gsettings set org.gnome.desktop.interface icon-theme " ^ name)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-ocaml">let _ = set_theme Xsettings Icon "Papirus-Dark" (* apply the function *)
</pre>
</div>
</div>
</div>
<div id="outline-container-org1141251" class="outline-2">
<h2 id="org1141251"><a href="#org1141251">The »Toggle« Function</a></h2>
<div class="outline-text-2" id="text-org1141251">
<p>
<b>Making a decision</b><br>
</p>

<p>
Until now, we have built two functions <code>get_theme</code> and <code>set_theme</code>. Let&rsquo;s use those in our third function and bring the action!<br>
</p>

<p>
Our toggle function needs to know several preferences to wield its magic. First, we are going to specify the preferences directly within the function with <code>let … in</code> bindings (for simplicity&rsquo;s sake). Later, when we know the function works, we are going to use a config file.<br>
</p>

<ul class="org-ul">
<li>Which backend to get/set the themes &#x2013;&gt; identifier <code>backend</code><br></li>
<li>Name of the currently active UI theme &#x2013;&gt; identifier <code>current_ui</code><br></li>
<li>Name of the dark UI theme &#x2013;&gt; identifier <code>ui_dark</code><br></li>
<li>Name of the light UI theme &#x2013;&gt; identifier <code>ui_light</code><br></li>
<li>Name of the dark icon theme &#x2013;&gt; identifier <code>icon_dark</code><br></li>
<li>Name of the light icon theme &#x2013;&gt; identifier <code>icon_light</code><br></li>
</ul>

<p>
&ldquo;Magic&rdquo; is a bit of an exaggeration – we use simple conditions here. As the themes come in pairs, <b>the program just needs to set &ldquo;the other one&rdquo;</b>. The decision which theme to set, depends on the <i>currently active</i> UI theme <code>current_ui</code>. So we&rsquo;re going to <code>match current_ui with</code> pattern(s).<br>
</p>

<ol class="org-ol">
<li>For the first branch, we can do:<br>
&ldquo;When <code>current_ui</code> equals the value of <code>ui_dark</code> -&gt; use the <code>backend</code> to set the UI theme <code>ui_light</code>; then use the <code>backend</code> to set the icon theme <code>icon_light</code>&rdquo;.<br></li>
<li>The second branch does the same, but vice-versa.<br></li>
<li>But what should happen if there has been set a different theme, which is none of the preconfigured dark/light theme pair? E.g. set by the XFCE appearance control panel? We can address this by introducing a third branch – the catch-all: Whenever the identifier <code>current_ui</code> carries an unexpected value, fall back to the preconfigured <code>ui_light</code> and <code>icon_light</code>.<br></li>
</ol>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 19: </span>Define the function</label><pre class="src src-ocaml">let toggle () =
  let backend = Xsettings in
  let current_ui = get_theme backend Ui in (* 2nd argument is the value above *)
  let ui_dark = "Adwaita-dark" in
  let ui_light = "Adwaita" in
  let icon_dark = "Papirus-Dark" in
  let icon_light = "Papirus-Light" in
  match current_ui with
  | c when String.equal c ui_dark -&gt;
    let _ = set_theme backend Ui ui_light in
    set_theme backend Icon icon_light
  | c when String.equal c ui_light -&gt;
    let _ = set_theme backend Ui ui_dark in
    set_theme backend Icon icon_dark
  | _ -&gt;
    let _ = set_theme backend Ui ui_light in
    set_theme backend Icon icon_light
</pre>
</div>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 20: </span>Apply the function eventually</label><pre class="src src-ocaml">let _ = toggle ()
</pre>
</div>

<p>
There may arise some questions:<br>
</p>
<ul class="org-ul">
<li><i>What does <code>c</code> mean in the 1st and 2nd branch?</i><br>
When matching a pattern, we can simultaneously bind one or more identifiers to certain parts of the matched object to use those parts in other places within the same branch. Here, we bind the whole value of <code>current_ui</code> to <code>c</code>.<br></li>
<li><i>What does the <code>when</code> keyword do?</i><br>
<code>when</code> introduces a <i>guard</i> expression. If the guard expression evaluates to <code>true</code>, then evaluate the expression after the arrow; if false, just continue with the next branch.<br></li>
<li><i>Why has the expression after the arrow the form <code>let _ = &lt;expression1&gt; in &lt;expression2&gt;</code>?</i><br>
We can use the nested <code>let … in</code> forms to do more than one thing after the other. And the single underscore (wildcard) means that we don&rsquo;t care to give it a name. It&rsquo;s evaluated only for its <i>side effects</i> (to trigger the shell commands).<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgd0aa8b6" class="outline-2">
<h2 id="orgd0aa8b6"><a href="#orgd0aa8b6">Paaartey! A working Prototype!</a></h2>
<div class="outline-text-2" id="text-orgd0aa8b6">
<p>
Ok ok, relax. We are not there yet. For now it runs in the toplevel, yes. Take a little break and do some Push-ups. Here&rsquo;s the code we cooked up so far:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 21: </span>Working prototype</label><pre class="src src-ocaml">type backend = Xsettings | Gsettings
type widget = Ui | Icon

let get_theme backend widget =
  let clean s =
    Str.global_replace (Str.regexp "^'\\|'$") "" s in
  match backend, widget with
  | Xsettings, Ui -&gt;
    clean (input_line
             (Unix.open_process_in
                "xfconf-query -c xsettings -p /Net/ThemeName"))
  | Xsettings, Icon -&gt;
    clean (input_line
             (Unix.open_process_in
                "xfconf-query -c xsettings -p /Net/IconThemeName"))
  | Gsettings, Ui -&gt;
    clean (input_line
             (Unix.open_process_in
                "gsettings get org.gnome.desktop.interface gtk-theme"))
  | Gsettings, Icon -&gt;
    clean (input_line
             (Unix.open_process_in
                "gsettings get org.gnome.desktop.interface icon-theme"))

let set_theme backend widget name =
  match backend, widget with
  | Xsettings, Ui -&gt;
    Unix.open_process
      ("xfconf-query -c xsettings -p /Net/ThemeName -s " ^ name)
  | Xsettings, Icon -&gt;
    Unix.open_process
      ("xfconf-query -c xsettings -p /Net/IconThemeName -s " ^ name)
  | Gsettings, Ui -&gt;
    Unix.open_process
      ("gsettings set org.gnome.desktop.interface gtk-theme " ^ name)
  | Gsettings, Icon -&gt;
    Unix.open_process
      ("gsettings set org.gnome.desktop.interface icon-theme " ^ name)

let toggle () =
  let backend = Xsettings in
  let current_ui = get_theme backend Ui in
  let ui_dark = "Adwaita-dark" in
  let ui_light = "Adwaita" in
  let icon_dark = "Papirus-Dark" in
  let icon_light = "Papirus-Light" in
  match current_ui with
  | c when String.equal c ui_dark -&gt;
    let _ = set_theme backend Ui ui_light in
    set_theme backend Icon icon_light
  | c when String.equal c ui_light -&gt;
    let _ = set_theme backend Ui ui_dark in
    set_theme backend Icon icon_dark
  | _ -&gt;
    let _ = set_theme backend Ui ui_light in
    set_theme backend Icon icon_light

let _ = toggle ()
</pre>
</div>

<p>
<a href="learn-ocaml-config-file-parsing-switch-gtk-theme.walktrough.html">We&rsquo;re going to finish this in the next episode!</a><br>
</p>

<p>
<b>Where do we stand now?</b><br>
</p>
<ul class="org-ul">
<li class="on">&#x2611; Determine the currently active GTK theme<br></li>
<li class="on">&#x2611; Toggle the UI (GTK) theme<br></li>
<li class="on">&#x2611; Change the icon theme accordingly<br></li>
</ul>

<p>
<b>What&rsquo;s next?</b><br>
</p>
<ul class="org-ul">
<li class="off">&#x2610; Read the preferences from a config file:<br>
<ul class="org-ul">
<li class="off">&#x2610; … preferred dark/light UI themes<br></li>
<li class="off">&#x2610; … preferred dark/light icon themes<br></li>
<li class="off">&#x2610; … which backend to use (either xsettings or gsettings)<br></li>
<li class="off">&#x2610; … or check/select the available backend automatically?<br></li>
</ul></li>
<li class="off">&#x2610; Write the initial config file if it doesn&rsquo;t exist yet<br></li>
<li class="off">&#x2610; Compile a standalone executable<br></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<div class="footer">Published by <span class="author"><a href="/bio.html">Dan Dee</a></span></div>
<script defer src="/static/footer.js"></script>
</div>
</body>
</html>
