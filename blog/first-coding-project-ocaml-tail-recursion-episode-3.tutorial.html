<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2025-12-03 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Eat my huge Files: Tail Recursion in OCaml</title>
<meta name="author" content="Dan Dee" />
<meta name="description" content="Coding project for beginners: &quot;CSV Cleaner&quot;: Tail recursion in OCaml – working with big lists" />
<meta name="keywords" content="tail recursion, tail call, recursive, ocaml, tutorial, project idea, learn ocaml, csv, pattern matching" />
<meta name="generator" content="Org Mode" />
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://wa.skred.net/; connect-src https://wa.skred.net/; style-src 'self' https://*; font-src 'self' https://*; img-src 'self' https://*; media-src 'self' https://*;">
<link rel="stylesheet" href="/static/normalize.css" type="text/css">
<link rel="stylesheet" href="/static/org.css" type="text/css">
<link rel="stylesheet" href="/static/style.css" type="text/css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cormorant:wght@300&family=Gentium+Plus:ital,wght@0,400;0,700;1,400;1,700&family=PT+Sans+Caption:wght@400;700&family=PT+Sans+Narrow:wght@400;700&family=PT+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/static/fonts/iosevka/fonts.css" type="text/css">
<link rel="icon" type="image/svg+xml" href="/static/monkeyjunglejuice.svg">
<link rel="apple-touch-icon" href="/static/monkeyjunglejuice-icon180.png">
<link rel="canonical" href="https://monkeyjunglejuice.github.io/blog/first-coding-project-ocaml-tail-recursion-episode-3.tutorial.html">
</head>
<body>
<div id="preamble" class="status">
<nav id="nav-primary"><a id="site-name" href="/index.html">MonkeyJungleJuice</a> <a id="index" href="/index.html">Index</a><a id="bio" href="/bio.html">Bio</a><a id="github" href="https://github.com/monkeyjunglejuice">Github</a></nav>
<div class="info"><time itemprop="dateModified" datetime="2025-03-24">Last updated: 2025-03-24</time></div>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Eat my huge Files: Tail Recursion in OCaml</h1>
<p class="subtitle" role="doc-subtitle">Project »CSV Cleaner« – 3rd Episode</p>
</header><nav class="pager" id="orge878514">
<p>
This post is part of a miniseries:<br>
</p>
<ol class="org-ol">
<li><a href="learning-to-code-first-app-episode-1.tutorial.html">Manipulation CSV Files in Common Lisp</a><br></li>
<li><a href="learning-to-code-first-ocaml-project-episode-2.tutorial.html">Rewrite in OCaml &#x2013; Tooling, Association Lists and Pattern Matching</a><br></li>
<li><b><a href="first-coding-project-ocaml-tail-recursion-episode-3.tutorial.html">Eat my Huge Files: Tail Recursion in OCaml</a></b><br></li>
</ol>
</nav>

<nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org89e454b">What is this about?</a>
<ul>
<li><a href="#orgef009fb">This Code Walktrough is for you, if …</a></li>
<li><a href="#orge0fe952">What can this Program do?</a></li>
</ul>
</li>
<li><a href="#org4a8bd6e">Ready for the funky Stuff?</a>
<ul>
<li><a href="#orgaa75b9f">My Benchmark Setup</a></li>
<li><a href="#orga4190fe">Let the Madness begin!</a></li>
<li><a href="#org9d56a06">Why did this happen?</a></li>
</ul>
</li>
<li><a href="#org165cb46">How can we use Recursive Functions safely?</a>
<ul>
<li><a href="#org0be109f">How to tell if a Function is (not) tail-recursive</a></li>
<li><a href="#org3380079">Recipe for tail-recursive Functions</a></li>
</ul>
</li>
<li><a href="#org844da61">Digesting really big CSV Files</a>
<ul>
<li><a href="#org887c8cb">Fixing the »Clean« Function</a></li>
<li><a href="#orgbb4e9cf">Fixing the »Dissoc« Function</a></li>
</ul>
</li>
<li><a href="#org07aa1e4">Oh how unsatisfying that was!</a>
<ul>
<li><a href="#org335d3aa">Bullet-proof »Clean« Function</a></li>
<li><a href="#org6e2cfc2">Bullet-proof »Dissoc« Function</a></li>
</ul>
</li>
<li><a href="#orgdc4c000">Final Comparison</a></li>
<li><a href="#orgf56c060">Conclusion</a></li>
<li><a href="#orgf7969d0">Full Code Listing, Version 0.3</a></li>
<li><a href="#org18e8830">What&rsquo;s next?</a></li>
</ul>
</div>
</nav>
<div id="outline-container-org89e454b" class="outline-2">
<h2 id="org89e454b"><a href="#org89e454b">What is this about?</a></h2>
<div class="outline-text-2" id="text-org89e454b">
<p>
This is the 3rd episode of a blog series where we walk through my very first coding project: a small command line utility to manipulate CSV files. I found it too tedious messing with spreadsheets, so I went on to automate it.<br>
</p>

<p>
I&rsquo;m a beginner on a journey to learn programming, so this is no authoritative guide how these things should be done. It&rsquo;s just that I learn stuff most throughly when I explain it to … you. Welcome!<br>
</p>

<p>
The project started in Common Lisp, and during the previous episode it got rewritten in OCaml. This episode builds on top of the former, so you might want to <a href="learning-to-code-first-ocaml-project-episode-2.tutorial.html">peek at the previous episode</a> in order to pick up the details.<br>
</p>
</div>
<div id="outline-container-orgef009fb" class="outline-3">
<h3 id="orgef009fb"><a href="#orgef009fb">This Code Walktrough is for you, if …</a></h3>
<div class="outline-text-3" id="text-orgef009fb">
<ul class="org-ul">
<li>you want to become a hacker (obviously)<br></li>
<li>you struggle with recursive functions<br></li>
<li>you want to learn how to write tail recursive functions<br></li>
<li>you are just curious about functional programming<br></li>
</ul>

<p>
If you want to follow the walktrough: For the most part you can just use <a href="https://try.ocaml.pro/">TryOCaml</a>, and there is a <a href="https://ocaml-learn-code.com/">free App for iOS</a> and <a href="https://play.google.com/store/apps/details?id=fr.vernoux.ocaml&amp;hl=en_US&amp;gl=US">Android</a>, too. But if you want to do all the stuff here (like compiling a binary), you&rsquo;ll need a working <a href="learning-to-code-first-ocaml-project-episode-2.tutorial.html#org786b2e7">OCaml setup</a> and an editor of your choice (my recommendation: invest some playtime into <a href="https://github.com/monkeyjunglejuice/emacs.onboard">Emacs</a>)<br>
</p>
</div>
</div>
<div id="outline-container-orge0fe952" class="outline-3">
<h3 id="orge0fe952"><a href="#orge0fe952">What can this Program do?</a></h3>
<div class="outline-text-3" id="text-orge0fe952">
<p>
Those features got implemented in the <a href="learning-to-code-first-ocaml-project-episode-2.tutorial.html">previous episode</a>:<br>
</p>

<ul class="org-ul">
<li class="on">&#x2611; Open and read a CSV file &ldquo;input.csv&rdquo;<br></li>
<li class="on">&#x2611; Remove some columns according to a &ldquo;template.csv&rdquo;<br></li>
<li class="off">&#x2610; Perform search and replace on cell content<br></li>
<li class="on">&#x2611; Set the pipe &rsquo;|&rsquo; as the delimiter char<br></li>
<li class="on">&#x2611; Spit out a sweet cleaned CSV file &ldquo;output.csv&rdquo;<br></li>
<li class="on">&#x2611; Compile to a standalone binary<br></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4a8bd6e" class="outline-2">
<h2 id="org4a8bd6e"><a href="#org4a8bd6e">Ready for the funky Stuff?</a></h2>
<div class="outline-text-2" id="text-org4a8bd6e">
<p>
I&rsquo;m super curious how the CSV Cleaner performs. Let&rsquo;s throw some really fat monster CSVs on it, with thousands … yeah, and millions of rows!<br>
</p>
</div>
<div id="outline-container-orgaa75b9f" class="outline-3">
<h3 id="orgaa75b9f"><a href="#orgaa75b9f">My Benchmark Setup</a></h3>
<div class="outline-text-3" id="text-orgaa75b9f">
<ol class="org-ol">
<li>Compile the <a href="learning-to-code-first-ocaml-project-episode-2.tutorial.html#orgcef6da3">CSV Cleaner v0.2</a> from the previous episode<br></li>
<li>Download some <a href="https://eforexcel.com/wp/downloads-18-sample-csv-files-data-sets-for-testing-sales/">sample data sets from &ldquo;EforExcel&rdquo;</a><br></li>
<li>Make a file <code>template.csv</code> stating which columns to keep in the cleaned CSV (dropping 7 of 14 columns)<br></li>
<li>Create a separate directory for each CSV with its own CSV Cleaner binary<br></li>
<li>Run CSV Cleaner on all CSVs and measure the time it takes to proceed the <code>output.csv</code> (10 runs per CSV; fastest run wins)<br></li>
</ol>
</div>
</div>
<div id="outline-container-orga4190fe" class="outline-3">
<h3 id="orga4190fe"><a href="#orga4190fe">Let the Madness begin!</a></h3>
<div class="outline-text-3" id="text-orga4190fe">
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Rows</th>
<th scope="col" class="org-right">Columns</th>
<th scope="col" class="org-right">Size MiB</th>
<th scope="col" class="org-right">User sec</th>
<th scope="col" class="org-right">System sec</th>
<th scope="col" class="org-right">Elapsed sec</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">100000</td>
<td class="org-right">14</td>
<td class="org-right">11.9</td>
<td class="org-right">0.59</td>
<td class="org-right">0.05</td>
<td class="org-right">0.65</td>
</tr>

<tr>
<td class="org-right">200000</td>
<td class="org-right">14</td>
<td class="org-right">23.4</td>
<td class="org-right">1.27</td>
<td class="org-right">0.12</td>
<td class="org-right">1.41</td>
</tr>

<tr>
<td class="org-right">300000</td>
<td class="org-right">14</td>
<td class="org-right">35.1</td>
<td class="org-right">2.01</td>
<td class="org-right">0.11</td>
<td class="org-right">2.13</td>
</tr>

<tr>
<td class="org-right">500000</td>
<td class="org-right">14</td>
<td class="org-right">59.5</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-right">1000000</td>
<td class="org-right">14</td>
<td class="org-right">119.0</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-right">5000000</td>
<td class="org-right">14</td>
<td class="org-right">595.1</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-org70e8a23" class="outline-4">
<h4 id="org70e8a23"><a href="#org70e8a23">Aaaaaand Crash!</a></h4>
<div class="outline-text-4" id="text-org70e8a23">
<p>
<code>Fatal error: exception Stack_overflow</code> somewhere on the way up to 500000 rows!<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org9d56a06" class="outline-3">
<h3 id="org9d56a06"><a href="#org9d56a06">Why did this happen?</a></h3>
<div class="outline-text-3" id="text-org9d56a06">
<p>
The <a href="https://en.wikipedia.org/wiki/Call_stack">call stack</a> or simply &ldquo;the stack&rdquo; is an area in memory that keeps track of the information associated with a function call. It can overflow because the stack is limited per thread of execution by the operating system, which leads to a certain &ldquo;stack depth&rdquo;, and therefore a maximum of function calls it can handle.<br>
</p>

<p>
In the CSV Cleaner program, we&rsquo;re making use of <i>recursive functions</i> – who call themselves in their own definition to iterate over <i>lists</i> (those are the data structures I&rsquo;ve implemented the rows of the CSV file in). Here is a simple example of such a recursive function that sums a list of numbers:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Recursive function</label><pre class="src src-ocaml">let rec sum l =                  (* function definition *)
  match l with
  | [] -&gt; 0                      (* 1 *)
  | hd :: tl -&gt; hd + (sum tl);;  (* 2 *)

sum [1; 2; 3; 4; 5];;            (* function call with a list as the argument*)
</pre>
</div>
</div>
<div id="outline-container-org72c177c" class="outline-4">
<h4 id="org72c177c"><a href="#org72c177c">How does this Function work?</a></h4>
<div class="outline-text-4" id="text-org72c177c">
<ol class="org-ol">
<li>&ldquo;If the list is empty, return 0 and stop.&rdquo;<br></li>
<li>&ldquo;Alternatively … take the first element of the list and … take the first element of the rest and … take the first element of the new rest … and so on and on, until the list is empty … then add everything up and return the value.&rdquo;<br></li>
</ol>

<p>
Here is how the <code>sum</code> function is applied to the list of 5 elements, producing 6 nested function calls (in the test before, we fed a list with 500000 elements to such a function). For each nested function call a new <i>stack frame</i> is created on the stack:<br>
</p>

<pre class="example" id="org7a7fce8">
sum &lt;-- [1; 2; 3; 4; 5]
sum &lt;-- [2; 3; 4; 5]
sum &lt;-- [3; 4; 5]
sum &lt;-- [4; 5]
sum &lt;-- [5]
sum &lt;-- []
sum --&gt; 0
sum --&gt; 5
sum --&gt; 9
sum --&gt; 12
sum --&gt; 14
sum --&gt; 15
- : int = 15
</pre>
</div>
</div>
<div id="outline-container-orgce08d41" class="outline-4">
<h4 id="orgce08d41"><a href="#orgce08d41">The Consequence</a></h4>
<div class="outline-text-4" id="text-orgce08d41">
<p>
If there are just enough nested function calls piling up, at some point the stack will be exhausted and we&rsquo;re getting a &ldquo;stack overflow&rdquo; (what actually piles up are the stack frames; those are data structures containing information about the function calls).<br>
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org165cb46" class="outline-2">
<h2 id="org165cb46"><a href="#org165cb46">How can we use Recursive Functions safely?</a></h2>
<div class="outline-text-2" id="text-org165cb46">
<p>
The OCaml compiler knows a technique which is called &ldquo;<a href="https://eklitzke.org/how-tail-call-optimization-works">Tail call optimization</a>&rdquo; (TCO). It has first and foremost nothing to do with recursion – but utilizing this technique, the compiler can produce instructions to re-use use the caller&rsquo;s stack frame for the recursive calls, instead of creating a new stack frame on top of another for each nested function call.<br>
</p>

<p>
There is one thing though: The recursive function has to be written in a certain way so that the compiler is able to optimize it: The function call to itself must be the very last thing that happens within one recursive cycle. Ok, but what does that mean?<br>
</p>
</div>
<div id="outline-container-org0be109f" class="outline-3">
<h3 id="org0be109f"><a href="#org0be109f">How to tell if a Function is (not) tail-recursive</a></h3>
<div class="outline-text-3" id="text-org0be109f">
<ol class="org-ol">
<li>Option: Recognize it yourself.<br>
Basically, you only need to know what will be evaluated before what.<br></li>
<li>Option: Check with the built-in &ldquo;ocaml.tailcall&rdquo; attribute.<br>
<code>[@tailcall]</code> can be applied in the recursive call (see below) in order to check if the call is a tail call. If it is no tail call, a warning is emitted.<br></li>
</ol>
</div>
<div id="outline-container-orgca521c7" class="outline-4">
<h4 id="orgca521c7"><a href="#orgca521c7">✘ Not tail-recursive</a></h4>
<div class="outline-text-4" id="text-orgca521c7">
<p>
Look at the recursive case (second branch). There&rsquo;s not only the call of the function <code>sum tl</code> itself, but another thing is happening too: the addition <code>hd +</code> … added to <i>what</i>? Yes, exactly … to the value of <code>sum tl</code> which has to be computed <i>before</i> the addition can happen. Ergo the recursive call is not the last thing, and therefore this is no &ldquo;tail call&rdquo;.<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let rec sum l =   (* function definition *)
  match l with
  | [] -&gt; 0
  | hd :: tl -&gt; hd + sum tl;;   (* &lt;-- recursive case *)

sum [1; 2; 3; 4; 5];;   (* applying the function to a list of numbers *)
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>Check for tail call</label><pre class="src src-ocaml">let rec sum l =
    match l with
    | [] -&gt; 0
    | hd :: tl -&gt; hd + (sum [@tailcall]) tl;;
</pre>
</div>
<p>
Check failed – warning:<br>
</p>
<pre class="example" id="orgab06b85">
Line 4, characters 23-42:
4 |     | hd :: tl -&gt; hd + (sum [@tailcall]) tl;;
                           ^^^^^^^^^^^^^^^^^^^^
Warning 51 [wrong-tailcall-expectation]: expected tailcall
val sum : int list -&gt; int = &lt;fun&gt;
</pre>
</div>
</div>
<div id="outline-container-org7fb4c8c" class="outline-4">
<h4 id="org7fb4c8c"><a href="#org7fb4c8c">✔ Tail-recursive</a></h4>
<div class="outline-text-4" id="text-org7fb4c8c">
<p>
Look at the recursive case again. The addition now happens in place of an additional argument <code>accu</code>. In fact, <code>hd</code> is added to the value of the accumulator, not to the value resulting from this recursive function call. That way, the addition can and will be computed before the function calls itself, which is therefore last thing happening. That&rsquo;s a &ldquo;tail call&rdquo;.<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let rec sumt accu l =       (* function definition with extra argument *)
  match l with
  | [] -&gt; accu
  | hd :: tl -&gt; sumt (accu + hd) tl;;   (* &lt;-- recursive case *)

sumt 0 [1; 2; 3; 4; 5];;   (* applying the function to a list of numbers *)
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>Check for tail call</label><pre class="src src-ocaml">let rec sumt accu l =
  match l with
  | [] -&gt; accu
  | hd :: tl -&gt; (sumt [@tailcall]) (accu + hd) tl;;
</pre>
</div>
<p>
Check passed – no warning:<br>
</p>
<div class="org-src-container">
<pre class="src src-ocaml">val sumt : int -&gt; int list -&gt; int = &lt;fun&gt;
</pre>
</div>

<p>
How do we get there?<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org3380079" class="outline-3">
<h3 id="org3380079"><a href="#org3380079">Recipe for tail-recursive Functions</a></h3>
<div class="outline-text-3" id="text-org3380079">
<p>
If you want to change a &ldquo;naive&rdquo; (non-tail-)recursive function into a tail-recursive function, you can follow these 4 steps (<a href="https://cs3110.github.io/textbook/chapters/basics/functions.html">source</a>):<br>
</p>

<ol class="org-ol">
<li>Change the original recursive function into a helper function<br>
<ul class="org-ul">
<li>rename it (often named <code>aux</code> for &ldquo;auxiliary&rdquo;)<br></li>
<li>add an extra argument: the accumulator, usually named <code>accu</code><br></li>
</ul></li>
<li>Now write the wrapper function <code>sum</code> that calls the helper function. It passes the original base case’s return value as the initial value of the accumulator.<br></li>
<li>Change the helper function to return the accumulator in the base case.<br></li>
<li>Change the helper function’s recursive case. It now needs to do the extra work on the accumulator argument, before the recursive call. This is the only step that requires much ingenuity.<br></li>
</ol>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>BEFORE – not tail-recursive</label><pre class="src src-ocaml">let rec sum l =
  match l with
  | [] -&gt; 0
  | hd :: tl -&gt; hd + (sum tl);;   (* recursive case: no tail call *)
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>AFTER – tail-recursive</label><pre class="src src-ocaml">let rec aux accu l =                   (* define the helper function *)
  match l with
  | [] -&gt; accu                         (* base case returns the accumulator *)
  | hd :: tl -&gt; aux (accu + hd) tl;;   (* recursive case: tail call *)

let sum l =   (* define the wrapper function *)
  aux 0 l;;   (* call helper function with the base case value *)
</pre>
</div>

<p>
Ok, now we&rsquo;ve got 2 separate functions, which is not really handy, right? So let&rsquo;s put the helper function <code>aux</code> into the <code>sum</code> function:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let sum l =
  let rec aux accu l =
    match l with
    | [] -&gt; accu
    | hd :: tl -&gt; aux (accu + hd) tl in
  aux 0 l;;
</pre>
</div>

<p>
And that&rsquo;s it! If you follow the recipe several times, you won&rsquo;t need it any more.<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org844da61" class="outline-2">
<h2 id="org844da61"><a href="#org844da61">Digesting really big CSV Files</a></h2>
<div class="outline-text-2" id="text-org844da61">
<p>
Now we&rsquo;re leaving the safe haven of simple, constructed examples and plunge into real-world recursive functions, one by one.<br>
</p>

<p>
Recursive functions in OCaml are easy to spot in the code (at least the ones <i>we</i> defined), because of their <code>let rec …</code> syntax, which enables a function to call itself.<br>
</p>
</div>
<div id="outline-container-org887c8cb" class="outline-3">
<h3 id="org887c8cb"><a href="#org887c8cb">Fixing the »Clean« Function</a></h3>
<div class="outline-text-3" id="text-org887c8cb">
<p>
The <code>clean</code> function receives the whole CSV data structure <code>tab</code> (table), which is essentially a long <i>list</i> containing <i>association lists</i> (rows) of <i>key-value pairs</i>. The latter represent single &ldquo;table cells&rdquo;, but each value (cell content) associated with its corresponding key (column header).<br>
</p>

<p>
Ah yes, not to forget: When writing about static functional languages, it&rsquo;s obligatory to barf out totally obvious type signatures like this. It&rsquo;s just a way to describe what form of data a function accepts for an argument, and what form the returned value will be:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>Type signature</label><pre class="src src-ocaml">val clean : (string * 'a) list list -&gt; (string * 'a) list list = &lt;fun&gt;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>BEFORE – causing a stack overflow</label><pre class="src src-ocaml">(** Drops the columns that are not specified in the template *)
let clean tab =
  let tpl_file = open_in "template.csv" in
  let tpl = tpl_file
            |&gt; Csv.of_channel ~has_header:true
            |&gt; Csv.Rows.header in
  let () = close_in tpl_file in
  let rec remove_cols tpl row =   (* 1 *)
    match row with
    | [] -&gt; []
    | (k, v) :: tl when List.mem k tpl -&gt; (k, v) :: remove_cols tpl tl
    | _ :: tl -&gt; remove_cols tpl tl in
  List.map (remove_cols tpl) tab   (* 2 *)
</pre>
</div>

<p>
Let&rsquo;s zoom in to the inner function <code>remove_cols</code> (1), which iterates through a single <i>association list</i> (row) specified by the <code>template.csv</code> in order to collect certain <i>key-value pairs</i> (column headers, cell content).<br>
</p>

<p>
&ldquo;<b>Wait … ROW you said?</b> When the CSVs have only 14 columns, then it means a list containing the data of a row is at most 14 elements long. A non-tail-recursive function eating this tiny list can hardly be the reason for the stack overflow!&rdquo;<br>
</p>

<p>
Very true Sherlock. As long as we don&rsquo;t clean CSVs with many thousands of columns per row, we ain&rsquo;t get into trouble because of that. So what&rsquo;s causing the stack overflow then?<br>
</p>

<p>
Well, there&rsquo;s also the function <code>List.map</code> (2) from OCaml&rsquo;s <a href="https://ocaml.org/api/List.html">List module</a> that iterates over the list <code>tab</code> containing the 500k CSV rows in order to apply <code>remove_cols</code> to each one of them. Here&rsquo;s that mighty beast:<br>
</p>
</div>
<div id="outline-container-org1709abc" class="outline-4">
<h4 id="org1709abc"><a href="#org1709abc">Tail-recursive or not?</a></h4>
<div class="outline-text-4" id="text-org1709abc">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>OCaml&rsquo;s official implementation</label><pre class="src src-ocaml">let rec map f = function
    [] -&gt; []
  | a::l -&gt; let r = f a in r :: map f l
</pre>
</div>

<p>
Looking at the recursive case <code>r :: map f l</code> where <code>r</code> is put into a list (via &ldquo;cons&rdquo; <code>::</code> operator) that still has to be computed by the recursive call(s) <code>map f l</code> tells us … what? That this is no tail call, so the function is not tail-recursive.<br>
</p>

<p>
I&rsquo;m quite surprised that such a fundamental function like <code>map</code> is not implemented tail-recursively by default. I mean OCaml is a functional programming language after all. Well, non-tail-recursive functions are marked in the <a href="https://ocaml.org/api/List.html">List module documentation</a>).<br>
</p>
</div>
</div>
<div id="outline-container-orgfc6eb1d" class="outline-4">
<h4 id="orgfc6eb1d"><a href="#orgfc6eb1d">What now?</a></h4>
<div class="outline-text-4" id="text-orgfc6eb1d">
<p>
Let&rsquo;s look for an alternative in the <a href="https://ocaml.org/api/List.html">List module</a> … Oh, what do we have here? &ldquo;<code>rev_map f l</code> gives the same result as <code>List.rev (List.map f l)</code>, but is <i>tail-recursive</i> and more efficient.&rdquo; Mmmh. Ok, I see. There it is.<br>
</p>

<p>
We could use <code>List.rev_map</code> instead of <code>List.map</code> then. Anything else? Yes, there&rsquo;s just … it returns the list in <i>reverse order</i>, as the name suggests … Well then we&rsquo;ll reverse the reversed list again via <code>List.rev</code>. And since we&rsquo;ll need a tail-recursive map function quite more often anyway, we can just wrap both in one and have our own tail-recursive &ldquo;map&rdquo; function:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">(** Tail-recursive alternative to [List.map] *)
let mapt f l =
  List.rev (List.rev_map f l)
</pre>
</div>

<p>
&ldquo;But isn&rsquo;t the additional step of reversing the linked list inefficient and slows down the program?&rdquo; I don&rsquo;t know, but I&rsquo;m curious too. So at the end of this walktrough, let&rsquo;s do a furious race between the different variants. But – patience, please. For the sake of completeness, here&rsquo;s the fixed function, with the single change in the last line:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">(** Drops the columns that are not specified in the template *)
let clean tab =
  let tpl_file = open_in "template.csv" in
  let tpl = tpl_file
            |&gt; Csv.of_channel ~has_header:true
            |&gt; Csv.Rows.header in
  let () = close_in tpl_file in
  let rec remove_cols tpl row =
    match row with
    | [] -&gt; []
    | (k, v) :: tl when List.mem k tpl -&gt; (k, v) :: remove_cols tpl tl
    | _ :: tl -&gt; remove_cols tpl tl in
  mapt (remove_cols tpl) tab   (* &lt;-- using our mapt here instead of List.map *)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbb4e9cf" class="outline-3">
<h3 id="orgbb4e9cf"><a href="#orgbb4e9cf">Fixing the »Dissoc« Function</a></h3>
<div class="outline-text-3" id="text-orgbb4e9cf">
<p>
It may not seem obvious, but <code>dissoc</code> is actually the definition of a function that takes one argument: the long list (table) holding the association lists (rows); each of them containing key-value pairs (column-header, cell content).<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>Type signature</label><pre class="src src-ocaml">val dissoc : ('a * 'a) list list -&gt; 'a list list = &lt;fun&gt;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span>BEFORE – causing a stack overflow</label><pre class="src src-ocaml">(** Transforms the (key, value) data structure into lists representing lines *)
let dissoc =
  let rec get_keys =
    function
    | [] -&gt; []
    | (k, _) :: tl -&gt; k :: get_keys tl in
  let rec get_values =
    function
    | [] -&gt; []
    | (_, v) :: tl -&gt; v :: get_values tl in
  function
  | [] -&gt; []                (* ↓ change this for mapt *)
  | hd :: tl -&gt; get_keys hd :: List.map get_values (hd :: tl)
</pre>
</div>

<p>
The CSV files we&rsquo;ve been using for the benchmark have thousands of rows, but only 14 columns. Both inner functions <code>get_keys</code> and <code>get_values</code> iterate through the &ldquo;rows&rdquo;, each of them containing as many key-value pairs as there are columns in the CSV.<br>
</p>

<p>
So we&rsquo;re getting away with those functions not being tail-recursive, as long as we feed them only &ldquo;small&rdquo; rows. But how small is &ldquo;small&rdquo;? The documentation says &ldquo;not longer than about 10000 elements&rdquo;; but this is no absolute guideline.<br>
</p>

<p>
Over all, same here as before with the <code>clean</code> function: <code>List.map</code> applies the function <code>get_values</code> to each of the 500k rows from the CSV, causing a stack overflow itself due its own non-tail-recursive implementation. Again, let&rsquo;s replace <code>List.map</code> with our tail-recursive alternative <code>mapt</code> and we&rsquo;re done:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span>AFTER – using the tail-recursive &rsquo;mapt&rsquo; alternative</label><pre class="src src-ocaml">(** Transforms the (key, value) data structure into lists representing lines *)
let dissoc =
  let rec get_keys =
    function
    | [] -&gt; []
    | (k, _) :: tl -&gt; k :: get_keys tl in
  let rec get_values =
    function
    | [] -&gt; []
    | (_, v) :: tl -&gt; v :: get_values tl in
  function
  | [] -&gt; []                (* ↓ using our tail-recursive version *)
  | hd :: tl -&gt; get_keys hd :: mapt get_values (hd :: tl)
</pre>
</div>

<p>
When we test the CSV Cleaner again in the toplevel, we should find a new CSV file <code>output.csv</code> in the project directory – even if we process a CSV file with 5 million lines.<br>
</p>
</div>
</div>
</div>
<div id="outline-container-org07aa1e4" class="outline-2">
<h2 id="org07aa1e4"><a href="#org07aa1e4">Oh how unsatisfying that was!</a></h2>
<div class="outline-text-2" id="text-org07aa1e4">
<p>
We&rsquo;ve just fixed the program by changing a tiny function in two places. Can you feel the emptiness, too? But you know what? Let&rsquo;s over-engineer the shit out of it and make <b>everything</b> tail-recursive, so the CSV cleaner can digest CSVs with as many rows AND columns as … I dont know … incredibly … many! Probably. Let&rsquo;s see.<br>
</p>
</div>
<div id="outline-container-org335d3aa" class="outline-3">
<h3 id="org335d3aa"><a href="#org335d3aa">Bullet-proof »Clean« Function</a></h3>
<div class="outline-text-3" id="text-org335d3aa">
<p>
Since we have already fixed the function <code>clean</code> by writing a tail-recursive alternative for <code>List.map</code>, we are now focussing on the inner function <code>remove_cols</code> that iterates over a single association list (row) in order to work on the key-value pairs:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let rec remove_cols tpl row =
  match row with
  | [] -&gt; []                                                           (* 1 *)
  | (k, v) :: tl when List.mem k tpl -&gt; (k, v) :: remove_cols tpl tl   (* 2 *)
  | _ :: tl -&gt; remove_cols tpl tl                                      (* 3 *)
</pre>
</div>
</div>
<div id="outline-container-orgbd29e81" class="outline-4">
<h4 id="orgbd29e81"><a href="#orgbd29e81">What is it doing?</a></h4>
<div class="outline-text-4" id="text-orgbd29e81">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 12: </span>Type signature</label><pre class="src src-ocaml">val remove_cols : 'a list -&gt; ('a * 'b) list -&gt; ('a * 'b) list = &lt;fun&gt;
</pre>
</div>

<p>
The function takes 2 arguments:<br>
</p>

<ul class="org-ul">
<li><code>tpl</code>: the template is one simple <i>list</i> <code>'a list</code> that holds the column headers of all columns to keep, while all others are getting dropped. This list looks like so:<br></li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 13: </span>Template data structure [&ldquo;columnheader&rdquo;; &ldquo;columnheader&rdquo;]</label><pre class="src src-ocaml">["b"; "c";]   (* list of column headers specifying the columns to keep *)
</pre>
</div>

<ul class="org-ul">
<li><code>row</code>: is a <i>list of tuples</i> <code>('a * 'b) list</code>. Those are key-value pairs; the key represents a column header, and the value represents the cell content:<br></li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 14: </span>Row data structure [(&ldquo;columnheader&rdquo;, &ldquo;cellcontent&rdquo;); … ]</label><pre class="src src-ocaml">[("a", "1"); ("b", "2"); ("c", "3"); ("d", "4")]   (* a single CSV row *)
</pre>
</div>
</div>
</div>
<div id="outline-container-org84506ea" class="outline-4">
<h4 id="org84506ea"><a href="#org84506ea">How does the inner Function work?</a></h4>
<div class="outline-text-4" id="text-org84506ea">
<ol class="org-ol">
<li>If the function receives a list <code>row</code> with nothing in it -&gt; return just an empty list.<br></li>
<li>Destructure the list <code>row</code> into the first key-value pair <code>(k, v)</code>, while referring to its parts with <code>k</code> for the &ldquo;key&rdquo; and <code>v</code> for the &ldquo;value&rdquo;; bind <code>tl</code> to the tail (rest) of the list (which is a list itself) – but only <code>when</code> the key <code>k</code> is also member of the template <code>tpl</code> -&gt; Then take the corresponding key-value pair … and again and again … put these into a list, and return that list eventually.<br></li>
<li>The 3rd branch takes over if the 2nd branch encounters a key <code>k</code> that is not member of the template <code>tpl</code> (those key-value pairs will be ignored). The 3rd branch just continues to call the function again with the next element from the tail <code>tl</code> of the list <code>row</code>.<br></li>
</ol>
</div>
</div>
<div id="outline-container-orgdd55442" class="outline-4">
<h4 id="orgdd55442"><a href="#orgdd55442">Making it tail-recursive</a></h4>
<div class="outline-text-4" id="text-orgdd55442">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 15: </span>BEFORE – not tail-recursive</label><pre class="src src-ocaml">let rec remove_cols tpl row =
  match row with
  | [] -&gt; []
  | (k, v) :: tl when List.mem k tpl -&gt; (k, v) :: remove_cols tpl tl (* 1 *)
  | _ :: tl -&gt; remove_cols tpl tl (* &lt;- that is already a tail call *)
</pre>
</div>

<p>
<a href="#org3380079">Maybe look at the recipe again</a>. The only part that can be kinda tricky is to rearrange the recursive case (1). The call to the function itself has to be the last thing happening, so that no other computation tries to use the value of that particular recursive call afterwards (within this recursive case/cycle).<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 16: </span>AFTER – helper function (1) and separate wrapper function (2)</label><pre class="src src-ocaml">let rec aux accu tpl row =   (* 1 *)
  match row with
  | [] -&gt; accu   (* &lt;-- replace the base case with the accumulator *)
  | (k, v) :: tl when List.mem k tpl -&gt; aux ((k, v) :: accu) tpl tl
  | _ :: tl -&gt; aux accu tpl tl

let remove_cols tpl row =   (* 2 *)
  aux [] tpl row   (* &lt;-- set the empty list [] as the base case *)
</pre>
</div>

<p>
Let&rsquo;s merge that into one single function:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 17: </span>AFTER – helper function (1) inside the wrapper function (2)</label><pre class="src src-ocaml">let remove_cols tpl row =   (* 2 *)
  let rec aux accu tpl row =   (* 1 *)
    match row with
    | [] -&gt; accu
    | (k, v) :: tl when List.mem k tpl -&gt; aux ((k, v) :: accu) tpl tl
    | _ :: tl -&gt; aux accu tpl tl in
  aux [] tpl row
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb77a31a" class="outline-4">
<h4 id="orgb77a31a"><a href="#orgb77a31a">Quick Test using the Toplevel (REPL)</a></h4>
<div class="outline-text-4" id="text-orgb77a31a">
<p>
How can we call this function and how should the arguments be like? The type signature tells us:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 18: </span>Yeah, hello again type signature. BFF!</label><pre class="src src-ocaml">val remove_cols : 'a list -&gt; ('a * 'b) list -&gt; ('a * 'b) list = &lt;fun&gt;
</pre>
</div>

<ul class="org-ul">
<li>The 1st argument <code>tpl</code> must be a list of single elements<br></li>
<li>The 2nd argument <code>row</code> must be a list of tuples with 2 elements each (key, value)<br></li>
<li>The result will also be a list of tuples with 2 elements each (key, value)<br></li>
</ul>

<p>
So for a quick test, we can just provide the arguments as follows:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 19: </span>Function call with two arguments (lists)</label><pre class="src src-ocaml">remove_cols ["b"; "c";] [("a", "1"); ("b", "2"); ("c", "3"); ("d", "4")]
         (* ↑ template  ↑ row *)
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 20: </span>Result – all the other key-value pairs got dropped</label><pre class="src src-ocaml">- : (string * string) list = [("c", "3"); ("b", "2")]
</pre>
</div>
</div>
<div id="outline-container-org4913480" class="outline-5">
<h5 id="org4913480"><a href="#org4913480">Noticed something?</a></h5>
<div class="outline-text-5" id="text-org4913480">
<p>
The key-value pairs came out in reverse order! There is one difference compared to the non-tail-recursive function: the helper function adds each key-value pair in front of the accumulator list <code>accu</code>, so the first pair found will eventually be at the end of the list.<br>
</p>

<p>
This is quite a common thing when recursively working on lists. What we can do, is to reverse the accumulator with <code>List.rev</code>, which itself <i>is</i> tail-recursive:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let remove_cols tpl row =
  let rec aux accu tpl row =
    match row with
    | [] -&gt; List.rev accu  (* &lt;-- reverse the accumulator *)
    | (k, v) :: tl when List.mem k tpl -&gt; aux ((k, v) :: accu) tpl tl
    | _ :: tl -&gt; aux accu tpl tl in
  aux [] tpl row
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orge8a9c2c" class="outline-4">
<h4 id="orge8a9c2c"><a href="#orge8a9c2c">Putting all together, going fully tail-recursive</a></h4>
<div class="outline-text-4" id="text-orge8a9c2c">
<p>
The <code>remove_cols</code> function is now tail-recursive and should be able to handle anything you throw at it. And off we go, putting it right back into the <code>csvcleaner.ml</code> file:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">(** Drops the columns that are not specified in the template *)
let clean tab =
  let tpl_file = open_in "template.csv" in
  let tpl = tpl_file
            |&gt; Csv.of_channel ~has_header:true
            |&gt; Csv.Rows.header in
  let () = close_in tpl_file in
  let remove_cols tpl row =     (* Here starts our new tail-recursive function *)
    let rec aux accu tpl row =
      match row with
      | [] -&gt; List.rev accu
      | (k, v) :: tl when List.mem k tpl -&gt; aux ((k, v) :: accu) tpl tl
      | _ :: tl -&gt; aux accu tpl tl in
    aux [] tpl row in           (* ... and it ends here *)
  mapt (remove_cols tpl) tab
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6e2cfc2" class="outline-3">
<h3 id="org6e2cfc2"><a href="#org6e2cfc2">Bullet-proof »Dissoc« Function</a></h3>
<div class="outline-text-3" id="text-org6e2cfc2">
<p>
We fixed the outer function <code>dissoc</code> already, now let&rsquo;s improve both inner functions <code>get_keys</code> and <code>get_values</code> to iterate over &ldquo;rows&rdquo; of arbitrary length without causing a stack overflow. CSV files with plenty of columns shouldn&rsquo;t pose any problem afterwards.<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">(** Transforms the key-value data structure into lists representing lines *)
let dissoc =
  let rec get_keys =   (* 1 *)
    function
    | [] -&gt; []
    | (k, _) :: tl -&gt; k :: get_keys tl in
  let rec get_values =   (* 2 *)
    function
    | [] -&gt; []
    | (_, v) :: tl -&gt; v :: get_values tl in
  function
  | [] -&gt; []
  | hd :: tl -&gt; get_keys hd :: mapt get_values (hd :: tl)
</pre>
</div>
</div>
<div id="outline-container-org294a4b4" class="outline-4">
<h4 id="org294a4b4"><a href="#org294a4b4">What is it doing?</a></h4>
<div class="outline-text-4" id="text-org294a4b4">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 21: </span>Type signature</label><pre class="src src-ocaml">val dissoc : ('a * 'a) list list -&gt; 'a list list = &lt;fun&gt;
</pre>
</div>

<p>
The <code>dissoc</code> function takes one argument, which is a <i>list of association lists</i> created by <code>clean</code>, containing only the columns specified by the template. Here you see how the structure literally looks like:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 22: </span>BEFORE – the whole CSV data is a list of association lists</label><pre class="src src-ocaml">[[("b", "2"); ("d", "4")];
 [("b", "6"); ("d", "8")];
 [("b", "10"); ("d", "12")]]
</pre>
</div>

<p>
The <code>dissoc</code> function splits the keys from the values and gathers both separately in order to change the structure into something that comes a bit closer to how a CSV file looks like:<br>
</p>

<ol class="org-ol">
<li>the first list becoming the first line a.k.a. table head<br></li>
<li>and the following lists becoming the table rows<br></li>
</ol>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 23: </span>AFTER – the whole CSV data is a list of lists</label><pre class="src src-ocaml">[["b"; "d"];     (* 1 *)
 ["2"; "4"];     (* 2 *)
 ["6"; "8"];     (* 2 *)
 ["10"; "12"]]   (* 2 *)
</pre>
</div>
</div>
</div>
<div id="outline-container-org89e32f4" class="outline-4">
<h4 id="org89e32f4"><a href="#org89e32f4">How do the inner Functions work?</a></h4>
<div class="outline-text-4" id="text-org89e32f4">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 24: </span>BEFORE – not tail-recursive</label><pre class="src src-ocaml">let rec get_keys =   (* 1 *)
  function
  | [] -&gt; []
  | (k, _) :: tl -&gt; k :: get_keys tl   (* ← ? *)

let rec get_values =   (* 2 *)
  function
  | [] -&gt; []
  | (_, v) :: tl -&gt; v :: get_values tl   (* ← ? *)
</pre>
</div>

<ol class="org-ol">
<li><code>val get_keys : ('a * 'b) list -&gt; 'a list = &lt;fun&gt;</code><br>
The outer function <code>dissoc</code> applies <code>get_keys</code> to each key-value pair of the first row, in order to collect only the keys and put them in a list.<br></li>
<li><code>val get_values : ('a * 'b) list -&gt; 'b list = &lt;fun&gt;</code><br>
The outer function <code>dissoc</code> applies <code>get_values</code> to each key-value pair of <i>all rows</i> in order to make a list of values from each row.<br></li>
</ol>
</div>
</div>
<div id="outline-container-org016d0bc" class="outline-4">
<h4 id="org016d0bc"><a href="#org016d0bc">Making both inner Functions tail-recursive</a></h4>
<div class="outline-text-4" id="text-org016d0bc">
<p>
Stoooop! Ok. Nah don&rsquo;t look further down. Wanna try to rewrite the functions on your own? I guess you propably don&rsquo;t even need the <a href="#org3380079">recipe</a> any more?<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 25: </span>AFTER – tail-recursive</label><pre class="src src-ocaml">let get_keys row =             (* Wrapper function *)
  let rec aux accu =           (* Helper function … *)
    function
    | [] -&gt; accu               (* … with accumulator *)
    | (k, _) :: tl -&gt; aux (k :: accu) tl in
  List.rev (aux [] row)        (* Don't forget to reverse the returned list *)

let get_values row =           (* Wrapper function *)
  let rec aux accu =           (* Helper function … *)
    function
    | [] -&gt; accu               (* … with accumulator *)
    | (_, v) :: tl -&gt; aux (v :: accu) tl in
  List.rev (aux [] row)        (* Reverse the returned list *)
</pre>
</div>
</div>
</div>
<div id="outline-container-org7a60cef" class="outline-4">
<h4 id="org7a60cef"><a href="#org7a60cef">Putting all together, one more time</a></h4>
<div class="outline-text-4" id="text-org7a60cef">
<p>
Just for the record, that&rsquo;s how the whole <code>dissoc</code> function looks afterwards:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let dissoc =
  let get_keys row =
    let rec aux accu =
      function
      | [] -&gt; accu
      | (k, _) :: tl -&gt; aux (k :: accu) tl in
    List.rev (aux [] row) in
  let get_values row =
    let rec aux accu =
      function
      | [] -&gt; accu
      | (_, v) :: tl -&gt; aux (v :: accu) tl in
    List.rev (aux [] row) in
  function
  | [] -&gt; []
  | hd :: tl -&gt; get_keys hd :: mapt get_values (hd :: tl)
</pre>
</div>
</div>
</div>
<div id="outline-container-org296d76d" class="outline-4">
<h4 id="org296d76d"><a href="#org296d76d">Quick Test in the Toplevel (REPL)</a></h4>
<div class="outline-text-4" id="text-org296d76d">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 26: </span>Applying the function to some data in the shape of <code>('a * 'a) list list</code></label><pre class="src src-ocaml">dissoc [[("b", "2"); ("d", "4")];
        [("b", "6"); ("d", "8")];
        [("b", "10"); ("d", "12")]];;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 27: </span>Result – the same data, but transformed into a <code>string list list</code></label><pre class="src src-ocaml">- : string list list = [["b"; "d"];
                        ["2"; "4"];
                        ["6"; "8"];
                        ["10"; "12"]]
</pre>
</div>

<p>
This list is then passed to the next function <code>save</code> to write the data to disk as a CSV file.<br>
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgdc4c000" class="outline-2">
<h2 id="orgdc4c000"><a href="#orgdc4c000">Final Comparison</a></h2>
<div class="outline-text-2" id="text-orgdc4c000">
<p>
Is there a difference in speed regarding the three implementations? Let&rsquo;s find out. There we have:<br>
</p>

<ul class="org-ul">
<li><b>&ldquo;no tr&rdquo;</b> the original variant without tail recursion<br></li>
<li><b>&ldquo;mapt only&rdquo;</b> where we only changed <code>List.map</code> for a tail-recursive <code>mapt</code><br></li>
<li><b>&ldquo;full tr&rdquo;</b> in which we&rsquo;ve made the row-functions tail-recursive too<br></li>
</ul>

<p>
There is to say that I&rsquo;ve been a bit lazy and just picked the fastest run out of ten for each variant per CSV size, so the method is probably as scientific as a lizard race in Thailand.<br>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Variant</th>
<th scope="col" class="org-right">Rows</th>
<th scope="col" class="org-right">Columns</th>
<th scope="col" class="org-right">Size MiB</th>
<th scope="col" class="org-right">User sec</th>
<th scope="col" class="org-right">System sec</th>
<th scope="col" class="org-right">Elapsed sec</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">no tr</td>
<td class="org-right">100000</td>
<td class="org-right">14</td>
<td class="org-right">11.9</td>
<td class="org-right">0.59</td>
<td class="org-right">0.05</td>
<td class="org-right">0.65</td>
</tr>

<tr>
<td class="org-left">mapt only</td>
<td class="org-right">100000</td>
<td class="org-right">14</td>
<td class="org-right">11.9</td>
<td class="org-right">0.58</td>
<td class="org-right">0.06</td>
<td class="org-right">0.65</td>
</tr>

<tr>
<td class="org-left">full tr</td>
<td class="org-right">100000</td>
<td class="org-right">14</td>
<td class="org-right">11.9</td>
<td class="org-right">0.62</td>
<td class="org-right">0.02</td>
<td class="org-right">0.65</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">no tr</td>
<td class="org-right">200000</td>
<td class="org-right">14</td>
<td class="org-right">23.4</td>
<td class="org-right">1.27</td>
<td class="org-right">0.12</td>
<td class="org-right">1.41</td>
</tr>

<tr>
<td class="org-left">mapt only</td>
<td class="org-right">200000</td>
<td class="org-right">14</td>
<td class="org-right">23.4</td>
<td class="org-right">1.32</td>
<td class="org-right">0.06</td>
<td class="org-right">1.40</td>
</tr>

<tr>
<td class="org-left">full tr</td>
<td class="org-right">200000</td>
<td class="org-right">14</td>
<td class="org-right">23.4</td>
<td class="org-right">1.30</td>
<td class="org-right">0.08</td>
<td class="org-right">1.39</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">no tr</td>
<td class="org-right">300000</td>
<td class="org-right">14</td>
<td class="org-right">35.1</td>
<td class="org-right">2.01</td>
<td class="org-right">0.11</td>
<td class="org-right">2.13</td>
</tr>

<tr>
<td class="org-left">mapt only</td>
<td class="org-right">300000</td>
<td class="org-right">14</td>
<td class="org-right">35.1</td>
<td class="org-right">1.92</td>
<td class="org-right">0.17</td>
<td class="org-right">2.10</td>
</tr>

<tr>
<td class="org-left">full tr</td>
<td class="org-right">300000</td>
<td class="org-right">14</td>
<td class="org-right">35.1</td>
<td class="org-right">1.97</td>
<td class="org-right">0.12</td>
<td class="org-right">2.11</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">no tr</td>
<td class="org-right">500000</td>
<td class="org-right">14</td>
<td class="org-right">59.5</td>
<td class="org-right">CRASH</td>
<td class="org-right">CRASH</td>
<td class="org-right">CRASH</td>
</tr>

<tr>
<td class="org-left">mapt only</td>
<td class="org-right">500000</td>
<td class="org-right">14</td>
<td class="org-right">59.5</td>
<td class="org-right">3.15</td>
<td class="org-right">0.15</td>
<td class="org-right">3.32</td>
</tr>

<tr>
<td class="org-left">full tr</td>
<td class="org-right">500000</td>
<td class="org-right">14</td>
<td class="org-right">59.5</td>
<td class="org-right">3.13</td>
<td class="org-right">0.17</td>
<td class="org-right">3.32</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">no tr</td>
<td class="org-right">1000000</td>
<td class="org-right">14</td>
<td class="org-right">119.0</td>
<td class="org-right">CRASH</td>
<td class="org-right">CRASH</td>
<td class="org-right">CRASH</td>
</tr>

<tr>
<td class="org-left">mapt only</td>
<td class="org-right">1000000</td>
<td class="org-right">14</td>
<td class="org-right">119.0</td>
<td class="org-right">6.47</td>
<td class="org-right">0.35</td>
<td class="org-right">6.86</td>
</tr>

<tr>
<td class="org-left">full tr</td>
<td class="org-right">1000000</td>
<td class="org-right">14</td>
<td class="org-right">119.0</td>
<td class="org-right">6.55</td>
<td class="org-right">0.34</td>
<td class="org-right">6.92</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">no tr</td>
<td class="org-right">5000000</td>
<td class="org-right">14</td>
<td class="org-right">595.1</td>
<td class="org-right">CRASH</td>
<td class="org-right">CRASH</td>
<td class="org-right">CRASH</td>
</tr>

<tr>
<td class="org-left">mapt only</td>
<td class="org-right">5000000</td>
<td class="org-right">14</td>
<td class="org-right">595.1</td>
<td class="org-right">31.27</td>
<td class="org-right">1.90</td>
<td class="org-right">33.28</td>
</tr>

<tr>
<td class="org-left">full tr</td>
<td class="org-right">5000000</td>
<td class="org-right">14</td>
<td class="org-right">595.1</td>
<td class="org-right">31.59</td>
<td class="org-right">1.76</td>
<td class="org-right">33.46</td>
</tr>
</tbody>
</table>

<p>
One might assume the tail-recursive CSV Cleaner variants (&ldquo;mapt only&rdquo;, &ldquo;full tr&rdquo;) were a bit faster than the one implementation &ldquo;no tr&rdquo; without tail recursion. When we compare both tail-recursive variants with each other, they seem to come pretty close, while the &ldquo;full tr&rdquo; seems a little behind.<br>
</p>

<p>
But in fact I think those differences are insignificant, because the variants are often only hundereds of milliseconds apart, and the results sometimes overlap. I guess that things like file system cache, processor cache, other background processes etc. matter much more.<br>
</p>
</div>
</div>
<div id="outline-container-orgf56c060" class="outline-2">
<h2 id="orgf56c060"><a href="#orgf56c060">Conclusion</a></h2>
<div class="outline-text-2" id="text-orgf56c060">
<p>
It makes sense to write functions in the tail-recursive style, since it eliminates the chance to run into a &ldquo;low-hanging&rdquo; ressource limit unneccessarily. But the next limit lurks just around the corner: the amount of total memory available. I did some runs on CSV files with 300000 rows but this time 400 columns instead of 14, and the process quickly ate up 16 GB RAM + 4 GB swap space and got killed by the OS eventually.<br>
</p>

<p>
Anyway, I had fun to gnaw on those larger files. Probably I should have used a data structure other than linked lists in the first place; and I&rsquo;m quite optimistic the whole task could be done more efficiently.<br>
</p>
</div>
</div>
<div id="outline-container-orgf7969d0" class="outline-2">
<h2 id="orgf7969d0"><a href="#orgf7969d0">Full Code Listing, Version 0.3</a></h2>
<div class="outline-text-2" id="text-orgf7969d0">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 28: </span>Fully tail-recursive</label><pre class="src src-ocaml">(* Version 0.3 *)

(** Tail-recursive alternative to [List.map] *)
let mapt f l =
  List.rev (List.rev_map f l)

(** Transforms the file into a key-value data structure *)
let prep file =
  let tab_file = open_in file in
  tab_file
  |&gt; Csv.of_channel
  |&gt; Csv.input_all
  |&gt; fun tab -&gt; let head, body =
                  match tab with
                  | [] -&gt; assert false
                  | hd :: tl -&gt; hd, tl in
  let () = close_in tab_file in
  Csv.associate head body

(** Drops the columns that are not specified by the template *)
let clean tab =
  let tpl_file = open_in "template.csv" in
  let tpl = tpl_file
            |&gt; Csv.of_channel ~has_header:true
            |&gt; Csv.Rows.header in
  let () = close_in tpl_file in
  let remove_cols tpl row =
    let rec aux accu tpl row =
      match row with
      | [] -&gt; List.rev accu
      | (k, v) :: tl when List.mem k tpl -&gt; aux ((k, v) :: accu) tpl tl
      | _ :: tl -&gt; aux accu tpl tl in
    aux [] tpl row in
  mapt (remove_cols tpl) tab

(** Transforms the key-value data structure into lists representing lines *)
let dissoc =
  let get_keys row =
    let rec aux accu =
      function
      | [] -&gt; accu
      | (k, _) :: tl -&gt; aux (k :: accu) tl in
    List.rev (aux [] row) in
  let get_values row =
    let rec aux accu =
      function
      | [] -&gt; accu
      | (_, v) :: tl -&gt; aux (v :: accu) tl in
    List.rev (aux [] row) in
  function
  | [] -&gt; []
  | hd :: tl -&gt; get_keys hd :: mapt get_values (hd :: tl)

(** Writes the cleaned CSV file to disk *)
let save tab =
  Csv.save ~separator:'|' ~quote_all:true tab

(** Puts all together in one pipe *)
let () = "input.csv"
         |&gt; prep
         |&gt; clean
         |&gt; dissoc
         |&gt; save "output.csv"
</pre>
</div>
</div>
</div>
<div id="outline-container-org18e8830" class="outline-2">
<h2 id="org18e8830"><a href="#org18e8830">What&rsquo;s next?</a></h2>
<div class="outline-text-2" id="text-org18e8830">
<p>
Right now I wonder how it would turn out to run the CSV Cleaner on multiple cores. But likely I&rsquo;m going to implement one or two of the pending features in the next episode.<br>
</p>

<ul class="org-ul">
<li class="on">&#x2611; Open and read a CSV file &ldquo;input.csv&rdquo;<br></li>
<li class="on">&#x2611; Remove some columns according to a &ldquo;template.csv&rdquo;<br></li>
<li class="off">&#x2610; Perform search and replace on cell content<br></li>
<li class="on">&#x2611; Set the pipe &rsquo;|&rsquo; as the delimiter char<br></li>
<li class="on">&#x2611; Spit out a sweet cleaned CSV file &ldquo;output.csv&rdquo;<br></li>
<li class="on">&#x2611; Compile to a standalone binary<br></li>
<li class="on">&#x2611; Make it work with bigger CSV files<br></li>
<li class="off">&#x2610; File selection via command line arguments<br></li>
<li class="off">&#x2610; Combine content of certain rows into one<br></li>
</ul>

<p>
Hope you enjoyed the walktrough. Suggestions are always welcome!<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<div class="footer">Published by <span class="author"><a href="/bio.html">Dan Dee</a></span></div>
<script defer src="/static/footer.js"></script>
</div>
</body>
</html>
