<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2025-12-03 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rewrite in OCaml: Tooling, Association Lists and Pattern Matching</title>
<meta name="author" content="Dan Dee" />
<meta name="description" content="A first coding project in OCaml – walktrough tutorial" />
<meta name="keywords" content="ocaml, tutorial, project idea, learn ocaml, walktrough, csv, pattern matching, ocaml scripting" />
<meta name="generator" content="Org Mode" />
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://wa.skred.net/; connect-src https://wa.skred.net/; style-src 'self' https://*; font-src 'self' https://*; img-src 'self' https://*; media-src 'self' https://*;">
<link rel="stylesheet" href="/static/normalize.css" type="text/css">
<link rel="stylesheet" href="/static/org.css" type="text/css">
<link rel="stylesheet" href="/static/style.css" type="text/css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cormorant:wght@300&family=Gentium+Plus:ital,wght@0,400;0,700;1,400;1,700&family=PT+Sans+Caption:wght@400;700&family=PT+Sans+Narrow:wght@400;700&family=PT+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/static/fonts/iosevka/fonts.css" type="text/css">
<link rel="icon" type="image/svg+xml" href="/static/monkeyjunglejuice.svg">
<link rel="apple-touch-icon" href="/static/monkeyjunglejuice-icon180.png">
<link rel="canonical" href="https://monkeyjunglejuice.github.io/blog/learning-to-code-first-ocaml-project-episode-2.tutorial.html">
</head>
<body>
<div id="preamble" class="status">
<nav id="nav-primary"><a id="site-name" href="/index.html">MonkeyJungleJuice</a> <a id="index" href="/index.html">Index</a><a id="bio" href="/bio.html">Bio</a><a id="github" href="https://github.com/monkeyjunglejuice">Github</a></nav>
<div class="info"><time itemprop="dateModified" datetime="2025-03-24">Last updated: 2025-03-24</time></div>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Rewrite in OCaml: Tooling, Association Lists and Pattern Matching</h1>
<p class="subtitle" role="doc-subtitle">Project »CSV Cleaner« – 2nd Episode</p>
</header><nav class="pager" id="orgb803a70">
<p>
This post is part of a miniseries:<br>
</p>
<ol class="org-ol">
<li><a href="learning-to-code-first-app-episode-1.tutorial.html">Manipulation CSV Files in Common Lisp</a><br></li>
<li><b><a href="learning-to-code-first-ocaml-project-episode-2.tutorial.html">Rewrite in OCaml &#x2013; Tooling, Association Lists and Pattern Matching</a></b><br></li>
<li><a href="first-coding-project-ocaml-tail-recursion-episode-3.tutorial.html">Eat my Huge Files: Tail Recursion in OCaml</a><br></li>
</ol>
</nav>

<nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org21c7ff3">Automate the Boring Stuff with OCaml</a>
<ul>
<li><a href="#org1de7cec">From Common Lisp to OCaml</a></li>
<li><a href="#org786b2e7">OCaml Installation and Project Setup</a></li>
</ul>
</li>
<li><a href="#org9306efb">What the Program should do</a></li>
<li><a href="#org24c9f5d">It&rsquo;s Library Shopping Time!</a></li>
<li><a href="#org9108e4b">How to open a File in OCaml</a>
<ul>
<li><a href="#orgafd1983">Types matter</a></li>
</ul>
</li>
<li><a href="#org35bb383">The CSV Library</a></li>
<li><a href="#orge181c01">Choosing a suitable Data Structure</a></li>
<li><a href="#org5df21f6">How to remove Columns from the CSV</a>
<ul>
<li><a href="#orgad8b992">The Good Ones into the List, the Bad Ones into the Garbage Collector</a></li>
</ul>
</li>
<li><a href="#org52a265e">Save the cleaned CSV to Disk</a></li>
<li><a href="#org5575760">Conclusion</a>
<ul>
<li><a href="#orgcb98e15">Full Code Listing</a></li>
</ul>
</li>
<li><a href="#org1cc37a7">Compile the Standalone Binary Executable</a></li>
<li><a href="#org0be8dff">What&rsquo;s next?</a></li>
</ul>
</div>
</nav>
<div id="outline-container-org21c7ff3" class="outline-2">
<h2 id="org21c7ff3"><a href="#org21c7ff3">Automate the Boring Stuff with OCaml</a></h2>
<div class="outline-text-2" id="text-org21c7ff3">
<p>
This tutorial is the 2nd episode of a little blog series where I extend, refactor and rewrite a small program with each episode. If you haven&rsquo;t read the <a href="learning-to-code-first-app-episode-1.tutorial.html">1st episode using Common Lisp</a>, you might like to check it out.<br>
</p>

<p>
I&rsquo;m on a journey to learn programming, and realized pretty early that I learn stuff best when I prepare myself to explain it to others.<br>
</p>

<p>
Usually, beginner projects involve programming little games like Ping Pong or Snake or whatever. For me, those kind of projects wouldn&rsquo;t have any other purpose than learning, and I wouldn&rsquo;t play that Ping Pong more than once afterwards.<br>
</p>

<p>
I find it more likely to stay committed when coding projects have a real world use case. This is why I&rsquo;m looking for &ldquo;problems&rdquo; in my own environment that I would like a computer to solve.<br>
</p>

<p>
What we&rsquo;re now doing here is manipulating CSV files. I find it tedious to do this by hand using a spreadsheet, so I wanted to automate the task. This little program doesn&rsquo;t do exciting things, but it serves well as a first trivial project.<br>
</p>
</div>
<div id="outline-container-org1de7cec" class="outline-3">
<h3 id="org1de7cec"><a href="#org1de7cec">From Common Lisp to OCaml</a></h3>
<div class="outline-text-3" id="text-org1de7cec">
<p>
I was using Common Lisp in the <a href="learning-to-code-first-app-episode-1.tutorial.html">previous episode</a>. Today I&rsquo;m going to rewrite everything in OCaml, because I&rsquo;m still not sure which programming language I like more. I think OCaml is a great programming language for beginners, because:<br>
</p>

<ul class="org-ul">
<li>There is <a href="https://cs3110.github.io/textbook/cover.html">excellent learning material</a> <i>(I just finished the <a href="https://cs3110.github.io/textbook/chapters/basics/exercises.html#">exercises chapter 2.9</a>)</i><br></li>
<li>The language has a coherent underlying concept<br></li>
<li>Actively developed by a highly engaged community<br></li>
<li>The syntax is clutter-free and easy to read<br></li>
<li>Source code can be compiled to small binaries<br></li>
<li>Multi-purpose and multi-paradigm<br></li>
<li>Packed with trend-setting features<br></li>
<li>OCaml is fast<br></li>
</ul>

<p>
I&rsquo;m not going to compare my experience with <b>Lisp vs. OCaml</b> this time, but probably do so in one of the coming episodes.<br>
</p>
</div>
</div>
<div id="outline-container-org786b2e7" class="outline-3">
<h3 id="org786b2e7"><a href="#org786b2e7">OCaml Installation and Project Setup</a></h3>
<div class="outline-text-3" id="text-org786b2e7">
<p>
If you would like to follow the tutorial, you&rsquo;ll need OCaml installed and set up on your machine. I won&rsquo;t go deeply into the setup process here, because it varies depending on the system you use (I use Linux with Emacs). But there&rsquo;s a comprehensive guide: <a href="https://ocaml.org/learn/tutorials/">Getting started with OCaml</a><br>
</p>
</div>
<div id="outline-container-org388d3fb" class="outline-4">
<h4 id="org388d3fb"><a href="#org388d3fb">Checklist</a></h4>
<div class="outline-text-4" id="text-org388d3fb">
<p>
No matter on which platform you are – when your setup is done, you should have at least OCaml&rsquo;s package manager <b>opam</b>.<br>
</p>

<ul class="org-ul">
<li><p>
<b>VSCode:</b> Install the packages from the commmand line and the <a href="https://open-vsx.org/extension/ocamllabs/ocaml-platform">OCaml Platform</a> extension<br>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Command line</label><pre class="src src-shell">opam install utop ocaml-lsp-server ocamlformat-rpc -y
</pre>
</div></li>

<li><p>
<b>Emacs:</b> Install the packages and run <i>user-setup</i><br>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>Command line</label><pre class="src src-shell">opam install user-setup merlin tuareg -y &amp;&amp;
opam user-setup install
</pre>
</div></li>

<li><p>
<b>Vim:</b> Install the packages and run <i>user-setup</i><br>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>Commmand line</label><pre class="src src-shell">opam install user-setup utop ocaml-lsp-server -y &amp;&amp;
opam user-setup install
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgdc56cc3" class="outline-4">
<h4 id="orgdc56cc3"><a href="#orgdc56cc3">Project setup</a></h4>
<div class="outline-text-4" id="text-orgdc56cc3">
<p>
We keep it short:<br>
</p>
<ol class="org-ol">
<li>Create a project folder <code>csvcleaner/</code> somewhere in your home directory<br></li>
<li>Create an empty file <code>csvcleaner/csvcleaner.ml</code> where the source code lives<br></li>
<li>Open the file <code>csvcleaner/csvcleaner.ml</code> in your editor of choice<br></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-org9306efb" class="outline-2">
<h2 id="org9306efb"><a href="#org9306efb">What the Program should do</a></h2>
<div class="outline-text-2" id="text-org9306efb">
<p>
Let&rsquo;s define the features first. A checked box means a feature is going to be implemented in this episode:<br>
</p>

<ul class="org-ul">
<li class="on">&#x2611; Open and read a CSV file <code>input.csv</code><br></li>
<li class="on">&#x2611; Remove some columns specified in <code>template.csv</code><br></li>
<li class="off">&#x2610; Perform search and replace on cell content<br></li>
<li class="on">&#x2611; Set the pipe &rsquo;|&rsquo; as the delimiter char<br></li>
<li class="on">&#x2611; Spit out a sweet cleaned CSV file <code>output.csv</code><br></li>
<li class="on">&#x2611; Compile to a standalone binary<br></li>
</ul>
</div>
</div>
<div id="outline-container-org24c9f5d" class="outline-2">
<h2 id="org24c9f5d"><a href="#org24c9f5d">It&rsquo;s Library Shopping Time!</a></h2>
<div class="outline-text-2" id="text-org24c9f5d">
<p>
It would be a way larger program if we would code everything from scratch. Let&rsquo;s look around for a library to work with CSV files: <a href="https://opam.ocaml.org/packages/">https://opam.ocaml.org/packages/</a>. Search for &ldquo;csv&rdquo; … Yep! Let&rsquo;s install &ldquo;Csv&rdquo; via <code>opam install csv</code><br>
</p>

<p>
Now back in the editor we want that library somehow recognized by OCaml, to be able to use it within our own program code. So do we have to load that library (or to use the right words: &ldquo;load a <i>module</i> from the <i>package</i>&rdquo;)? Is there an import statement or something that we have to put into the source file? What happens when we put this into the source file?<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>Example – not part of the program code</label><pre class="src src-ocaml">open Csv
</pre>
</div>

<p>
Turns out the line <code>open Csv</code> above produces an error &ldquo;Unbound module Csv&rdquo; immediately when I save the file, although everything is properly installed and configured. So what&rsquo;s happening here? The error comes from Merlin resp. Ocamllsp who uses Merlin under the hood. Among other things, Merlin checks the source file for errors each time you save it. Merlin should be already installed via opam as a dependency of &rsquo;user-setup&rsquo; or &rsquo;ocaml-lsp-server&rsquo;.<br>
</p>

<p>
It took me 2 hours to learn Merlin seems to need a file named <code>.merlin</code> within the project folder in which the Csv module has to be listed. I&rsquo;ve read somewhere else the <code>csvcleaner/.merlin</code> file is not neccessary when using Dune, which is the en vogue <i>build system</i> for OCaml.<br>
</p>

<p>
Back to <code>open Csv</code>. Hm no, that&rsquo;s something slightly different. Once a module is within the search path – which seems to be the case when a <del>module or library</del> package was installed via Opam – then we can refer to a function from that module by &ldquo;Modulename.functionname&rdquo; (analogy: Familyname.firstname), e.g. <code>Csv.lines</code>, which is a function that spits out how many lines a CSV has. We need to <code>open Csv</code> only if we want to omit the function&rsquo;s &ldquo;family name&rdquo; and refer to that function by it&rsquo;s &ldquo;first name&rdquo; only. I use the full names and don&rsquo;t care about that for now.<br>
</p>

<p>
We definitely want to use a build system. It makes compiling super easy, avoiding endless command line arguments, messing with module paths and other labourous things. So install Dune via Opam from the command line, if not done yet: <code>opam install dune</code>. Dune requires a configuration file describing the project details, e.g. which libraries to use, and so on. So let&rsquo;s create a file named <code>csvcleaner/dune</code> with the following content:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>File content – csvcleaner/dune</label><pre class="src src-dune">(executable
 (name csvcleaner)
 (libraries csv))
</pre>
</div>

<p>
Pretty self-explaining I guess. There are more stanzas to hold further project information, but these are enough for our little program.<br>
</p>

<p>
When the file exists, we can issue the command <code>dune build</code> from the command line to build the (not yet existing) project. The process creates some build artifacts in <code>csvcleaner/_build</code>. And for the first time, Merlin recognizes the &ldquo;Csv&rdquo; module and shows contained functions via autocompletion in Emacs.<br>
</p>

<p>
In Emacs (Lisp), you can &ldquo;execute code&rdquo; (nah we don&rsquo;t do that! We evaluate expressions!) from within a source file simply by placing the cursor behind an expression and hitting C-x C-e (that means holding down the &lt;CTRL&gt; key and pressing &lt;x&gt; and then &lt;e&gt;). Analogous, in VSCode you can evaluate a selection by holding down &lt;SHIFT&gt; and pressing &lt;ENTER&gt;.<br>
</p>

<p>
Those keybindings start the OCaml toplevel, either <i>utop</i> or <i>ocaml</i>.<br>
</p>

<p>
In Emacs, the error &ldquo;Unbound module Csv&rdquo; appears again, but this time in the toplevel. Turns out, the toplevel doesn&rsquo;t know yet about the module we told Merlin about. The <del>module</del> package has to be loaded in the toplevel separately, using another command <code>#require "csv"</code>. Or better: create a file in the project directory <code>csvcleaner/.ocamlinit</code> with the following 2 lines:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>File content – csvcleaner/.ocamlinit</label><pre class="src src-ocaml">#use "topfind";;
#require "csv";;
</pre>
</div>

<p>
That way, the toplevel <i>ocaml</i> or <i>utop</i> will load the <del>module</del> &ldquo;csv&rdquo; package at startup. If you use utop, everything should be fine from now on.<br>
</p>

<p>
If you use Emacs, auto-completion is probably not yet available within the <i>ocaml</i> toplevel. But `M-x merlin-use &lt;RET&gt; csv &lt;RET&gt;&rsquo; will do the trick. I probably can fix this with a few lines of Emacs Lisp later.<br>
</p>

<p>
If you use VSCode, I guess everything just works out of the box when the <a href="https://open-vsx.org/extension/ocamllabs/ocaml-platform">OCaml Platform</a> extension is installed and the <i>language server</i> via <code>opam install ocaml-lsp-server</code>. You problably haven&rsquo;t had to learn all those details.<br>
</p>
</div>
</div>
<div id="outline-container-org9108e4b" class="outline-2">
<h2 id="org9108e4b"><a href="#org9108e4b">How to open a File in OCaml</a></h2>
<div class="outline-text-2" id="text-org9108e4b">
<p>
Let&rsquo;s begin with Input/Output. We will try to open and read the CSV file, store its contents in the memory and use a variable to refer to the data, in order to manipulate it later. How do I open a file in OCaml? The <a href="https://ocaml.org/learn/tutorials/file_manipulation.html">tutorial section</a> on the website helps, here is what I found out:<br>
</p>

<p>
Open files are called <i>channels</i> in OCaml. There&rsquo;s a function <code>open_in</code> to open a file. This function takes the path of the file as a <code>string</code> and returns a type <code>in_channel</code>, which seems to be … an abstraction for the open file (?) And there&rsquo;s another function <code>close_in</code> to close the channel/file again. Let&rsquo;s try!<br>
</p>

<p>
You can type this in your file <code>csvcleaner/csvcleaner.ml</code> and then evaluate those expressions directly (&ldquo;send to REPL&rdquo; or something), if your editor allows to do that:<br>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>Example – not part of the program code</label><pre class="src src-ocaml">let csv_file' = open_in "input.csv"
(* &lt;-- Do some stuff here --&gt; *)
let () = close_in csv_file'
</pre>
</div>

<p>
If your editor can&rsquo;t do that, open <b>utop</b> in your terminal emulator and type the lines like this. Notice the <code>;;</code> two semicolons after each expression. You need <code>;;</code> only in the interactive toplevel, but not in your code:<br>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>Example – not part of the program code</label><pre class="src src-ocaml">let csv_file' = open_in "input.csv";;
(* &lt;-- Do some stuff here --&gt; *)
let () = close_in csv_file';;
</pre>
</div>

<p>
You probably wonder about the <code>'</code> ASCII apostrophe at the end of some variable- or function names. That basically means &ldquo;same same but different&rdquo; – I use <code>'</code> to mark examples or alternatives that are not part of the program code.<br>
</p>
</div>
<div id="outline-container-orgafd1983" class="outline-3">
<h3 id="orgafd1983"><a href="#orgafd1983">Types matter</a></h3>
<div class="outline-text-3" id="text-orgafd1983">
<p>
The value bound to the variable <code>csv_file'</code> has the <i>type</i> <code>in_channel</code>. So now we need another function that can do something with a piece of data with the type <code>in_channel</code>. Types matter a lot in OCaml, you will see that later.<br>
</p>

<p>
The <code>in_channel</code> is something that enables us to read a file and points to the beginnning of the file. Still it seems we are pretty far from having the content of the CSV file available as a <i>data structure</i> that we can manipulate at will. Maybe it&rsquo;s time to let the <code>Csv</code> module take over? Nah, not so fast. Let&rsquo;s poke a little bit on that channel thing. I&rsquo;m curious how it behaves and what I can get out of it.<br>
</p>

<p>
Cool, I found out there are a couple functions that begin with &ldquo;input_&rdquo; and they all can operate on the type <code>in_channel</code>! Most of them are &ldquo;built-in&rdquo;; that means they are members of the module &ldquo;Stdlib&rdquo; which is always loaded by default. I&rsquo;ve stumbled upon the available functions via auto-completion – it&rsquo;s one of the most life changing inventions of humankind and comes right after the dishwasher, which is of course the greatest of all accomplishments of all time.<br>
</p>

<p>
Let&rsquo;s write a couple of functions to get stuff out of that channel. So there&rsquo;s <code>input_line</code>: That one reads one line from the file and makes a string out of it. The next time we apply that function, it outputs the next line and so on, until the whole channel is &ldquo;consumed&rdquo;. So that&rsquo;s probably not a <i>pure</i> function (those always return the same output with the same input)?<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>Example – not part of the program code</label><pre class="src src-ocaml">let csv_file' = open_in "input.csv"
let () = print_endline (input_line csv_file')
let () = close_in csv_file'
</pre>
</div>

<p>
And here&rsquo;s another function <code>input_char</code> in the Stdlib that returns the content of the stream character-wise. But we cannot print it to the screen via <code>print_endline</code>, because that particular print function can only print data of the type <code>string</code>. But <code>input_char</code> returns data from the type <code>char</code>, so we either need to convert the chars into strings, or we have to use another function that prints chars directly. Same here: it spits out one char after another, until the channel is &ldquo;consumed&rdquo;:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span>Example – not part of the program code</label><pre class="src src-ocaml">let csv_file' = open_in "input.csv"
let () = print_char (input_char csv_file')
let () = close_in csv_file'
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org35bb383" class="outline-2">
<h2 id="org35bb383"><a href="#org35bb383">The CSV Library</a></h2>
<div class="outline-text-2" id="text-org35bb383">
<p>
The auto-completion suggests another function <code>Csv.input_all</code> which is part of the <code>Csv</code> module. Instead of building up a data structure from single lines, perhaps we can get a bit more convenience using more of the <code>Csv</code> module functionality from here on? Let&rsquo;s try it.<br>
</p>

<p>
But I cannot apply <code>Csv.input_all</code> to <code>csv_file'</code> which is of type <code>in_channel</code>, because it expects its arguments to be of the type <code>Csv.in_channel</code>, not <code>in_channel</code>. I&rsquo;m confused.<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span>Example – not part of the program code</label><pre class="src src-ocaml">let csv_file' = open_in "input.csv"
let () = print_endline (Csv.input_all csv_file') (* ← Nah, not working! Wrong type! *)
let () = close_in csv_file'
</pre>
</div>

<p>
Why is <code>csv_file'</code> of type <code>in_channel</code>? Because <code>open_in</code> is. Does it mean we&rsquo;ll better not use the function <code>open_in</code> to open the file but something else?<br>
</p>

<p>
Nope, I think I have found something: the function <code>Csv.of_channel</code>. It can transform the <code>csv_file'</code> into something we can manipulate conveniently … well, hold on.<br>
</p>

<p>
We will now transform the data from <code>csv_file</code> in 3 steps into a data structure we can manipulate.<br>
</p>
<ol class="org-ol">
<li>We apply the function <code>Csv.of_channel</code> from the Csv library on the <code>csv_file</code> to set the reading parameters and eventually read the data from the <code>csv_file</code>.<br></li>
<li>Now we apply the function <code>Csv.input_all</code> on the returned value from the function <code>Csv.of_channel</code> to construct a nested list from the content of the CSV file, where each row becomes a list of strings.<br></li>
<li>We bind a variable to that nested list, so we can refer to it later.<br></li>
</ol>

<div class="org-src-container">
<pre class="src src-ocaml">let csv_file = open_in "input.csv"

let table =          (* 3. Variable bound to the list of lists *)
  Csv.input_all      (* 2. That function makes a list of lists from the CSV content *)
    (Csv.of_channel  (* 1. This function reads what's found in the [csv_file] *)
       csv_file)     (*    The "normal" [in_channel] passed as an argument *)

let () = close_in csv_file  (* We have all we need, let's close that file *)
</pre>
</div>

<p>
So far the nested list we created in the 3 steps above looks like below. In that list, the column headers &ldquo;a&rdquo;, &ldquo;b&rdquo;, &ldquo;c&rdquo; and &ldquo;d&rdquo; convey no special meaning; even tough they sit in the first row, they are nothing more than just a list of strings like all the other rows.<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 13: </span>Result – not part of the program code</label><pre class="src src-ocaml">val table : Csv.t =
            [["a"; "b"; "c"; "d"];
             ["1"; "2"; "3"; "4"];
             ["5"; "6"; "7"; "8"];
             ["9"; "10"; "11"; "12"]]
</pre>
</div>
</div>
</div>
<div id="outline-container-orge181c01" class="outline-2">
<h2 id="orge181c01"><a href="#orge181c01">Choosing a suitable Data Structure</a></h2>
<div class="outline-text-2" id="text-orge181c01">
<blockquote>
<p>
&ldquo;It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures.&rdquo;<br>
<cite>—Alan Perlis</cite><br>
</p>
</blockquote>

<p>
<a href="learning-to-code-first-app-episode-1.tutorial.html">In the previous episode</a> I was just using a simple <i>list of lists</i> like above as my primary data structure; and then I removed the columns (cells) from each row by their position. This is a bit awkward to work with but ok, because I treated the data like it was immutable. This time we go one step further.<br>
</p>

<p>
In order to conveniently manipulate the data, we want to associate <i>meaning</i> (column headers) with the <i>content</i> (table cells). To connect each column header with the cells who belong to the same column, we can transform the table above into another data structure that will allow such association: enter the <i>association list</i> a.k.a. <i>map</i> or <i>dictionary</i>.<br>
</p>

<p>
In OCaml, an association list is usually implemented as a list containing <i>tuples</i>. The first element in the tuple <code>"a"</code> is the &ldquo;key&rdquo;, and the second element <code>"1"</code> is the &ldquo;value&rdquo;. The parens around tuples can be omitted. So that means if you encounter two or more things in OCaml code separated by a comma, it&rsquo;s actually a tuple – parens or not:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 14: </span>Example – not part of the program code</label><pre class="src src-ocaml">let example_alist' = [("a", "1"); ("b", "2"); ("c", "3"); ("d", "4")]
let example_alist'' = ["a", "1"; "b", "2"; "c", "3"; "d", "4"]
</pre>
</div>

<p>
The Csv module provides a convenient function <code>Csv.associate</code> that transforms the <code>table</code> into such an association list, but it expects the data for its arguments to be of a certain type. And here&rsquo;s the type signature of the function <code>Csv.associate</code>. It says what type of arguments the function wants and of what the return value will be:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 15: </span>Example – not part of the program code</label><pre class="src src-ocaml">string list -&gt; string list list -&gt; (string * string) list list
</pre>
</div>

<ul class="org-ul">
<li>The 1st argument must be a string list -&gt;<br></li>
<li>The 2nd argument must be a string list, wrapped in another list -&gt;<br></li>
<li>Returns what: two-string tuples, wrapped in lists, wrapped in another list<br></li>
</ul>

<p>
Let&rsquo;s find a way to provide the arguments exactly like that. If we don&rsquo;t, we&rsquo;ll get a type error. The first argument will deliver the column headers to the function, and the second argument will deliver the other rows (lists) containing the single cells (strings).<br>
</p>

<p>
We split that <code>table</code> into the &ldquo;head&rdquo; <i>(that&rsquo;s a common concept and means the first element of a list)</i> and refer to it with the variable <code>header</code>.<br>
</p>

<p>
Then we take the &ldquo;tail&rdquo; of the list <i>(also a common term in programming which means the rest of a list, which is itself a list of the remaining elements of the original list)</i> and refer to it with the variable <code>content</code>:<br>
</p>

<p>
The expression below deserves some explanation. What we see there, is <i>pattern matching</i>, a technique available in some programming languages from the &ldquo;functional&rdquo; corner, eg. Haskell, Erlang, Elixir or Common Lisp. Other mainstream languages might get it bolted on in the future.<br>
</p>

<p>
What it does: Pattern matching is a form of conditional branching which allows you to match on data structure patterns and bind variables <i>at the same time</i>. It helps to produce clean, concise code. For example, we can avoid those clumsy nested if-then-else-if constructs. I&rsquo;m a huge fan of pattern matching and it&rsquo;s everywhere in OCaml.<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 16: </span>Multiple assignment via pattern matching</label><pre class="src src-ocaml">let header, content =
  match table with
  | [] -&gt; assert false
  | hd :: tl -&gt; hd, tl
</pre>
</div>

<p>
In the definition above, we take the <code>table</code> which is essentially a <i>list</i> data structure with other lists in it. A list can be divided into sub-structures, the &ldquo;head&rdquo; and &ldquo;tail&rdquo;; in Lisp called &ldquo;car&rdquo; and &ldquo;cdr&rdquo;, or sometimes &ldquo;first&rdquo; and &ldquo;rest&rdquo;.<br>
</p>

<p>
On the left side of the branch (left of the arrow) we write down the pattern and assign variables to the sub-structures we want to use later (in that case <code>hd</code> for &ldquo;head&rdquo; and <code>tl</code> for &ldquo;tail&rdquo;) -&gt; On the right side of the branch, we write down what to do with those variables. In our case here, the right side says &ldquo;construct a tuple from <code>hd</code> and <code>tl</code>&rdquo; which is concisely expressed as <code>hd, tl</code>, or <code>(hd, tl)</code>.<br>
</p>

<p>
Note that it doesn&rsquo;t matter how we name those variables – they don&rsquo;t have to be named <code>hd</code> and <code>tl</code> – they could as well be <code>brain</code> and <code>pinky</code>. The crucial detail is the cons operator <code>::</code> who does only one thing: construct a list from an empty list <code>[]</code> and one or more elements: <code>"a" :: "b" :: "c" :: "d" :: []</code> You recognize the pattern here?<br>
</p>

<p>
If the <code>table</code> is not an empty list, then the expression will return the tuple <code>hd, tl</code> containing the head and the tail of the <code>table</code>. What it does then, is <a href="https://ocamlbook.org/algebraic-types/#pattern-matching">multiple assignment by another act of pattern matching</a>: The the returned tuple <code>hd, tl</code> is matched against the pattern <code>header</code>, <code>content</code> so that the value from <code>hd</code> is assigned to <code>header</code> and from <code>tl</code> to <code>content</code>.<br>
</p>

<p>
When we evaluate the expression above, we finally get the following values, and they have the desired types expected by the function <code>Csv.associate</code>:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 17: </span>Results – not part of the program code</label><pre class="src src-ocaml">val header : string list = ["a"; "b"; "c"; "d"]

val content : string list list =
              [["1"; "2"; "3"; "4"];
               ["5"; "6"; "7"; "8"];
               ["9"; "10"; "11"; "12"]]
</pre>
</div>

<p>
Eventually we can apply the function <code>Csv.assocciate</code> to combine each column header element with the content cells who belong to it:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 18: </span>Function application</label><pre class="src src-ocaml">let table_assoc = Csv.associate header content
</pre>
</div>

<p>
That&rsquo;s how our table looks like after the transformation – the column headers &ldquo;a&rdquo;, &ldquo;b&rdquo;, &ldquo;c&rdquo;, and &ldquo;d&rdquo; have been associated with the corresponding table cells:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 19: </span>Result – not part of the program code</label><pre class="src src-ocaml">val table_assoc : (string * string) list list =
                  [[("a", "1"); ("b", "2"); ("c", "3"); ("d", "4")];
                   [("a", "5"); ("b", "6"); ("c", "7"); ("d", "8")];
                   [("a", "9"); ("b", "10"); ("c", "11"); ("d", "12")]]
</pre>
</div>
</div>
</div>
<div id="outline-container-org5df21f6" class="outline-2">
<h2 id="org5df21f6"><a href="#org5df21f6">How to remove Columns from the CSV</a></h2>
<div class="outline-text-2" id="text-org5df21f6">
<p>
We will use another CSV that is going to serve as a template to specify which columns to keep. We can use almost the same construct like before where we read the file <code>input.csv</code>. But since we need only the first row of the <code>template.csv</code>, we&rsquo;ll make sure to get only that.<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 20: </span>Creating the template</label><pre class="src src-ocaml">let template_file = open_in "template.csv"

let template =
  Csv.Rows.header
    (Csv.of_channel ~has_header:true
       template_file)

let () = close_in template_file
</pre>
</div>

<p>
So far we have read, transformed and stored the template in memory, bound it to a variable and closed the file.<br>
</p>

<p>
Small detail on the side: in OCaml we can write <i>function application</i> like so – pipe a value trough some functions – using the &ldquo;pipe operator&rdquo;:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 21: </span>Alternative – not part of the program code</label><pre class="src src-ocaml">let template' = template_file
                |&gt; Csv.of_channel ~has_header:true
                |&gt; Csv.Rows.header
</pre>
</div>

<p>
And here&rsquo;s the return value:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 22: </span>Result – not part of the program code</label><pre class="src src-ocaml">val template' : string list = ["b"; "d"]
</pre>
</div>
</div>
<div id="outline-container-orgad8b992" class="outline-3">
<h3 id="orgad8b992"><a href="#orgad8b992">The Good Ones into the List, the Bad Ones into the Garbage Collector</a></h3>
<div class="outline-text-3" id="text-orgad8b992">
<p>
&ldquo;Removing columns&rdquo; is actually misleading: Technically, the function does not remove or delete anything, because … its impossible! Lists in OCaml are immutable – they cannot be changed. So what we will do instead: construct a new list from the columns we want to keep, according to the column headers specified by the template. And simply forget about the others.<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 23: </span>Recursive function using pattern matching on a list of tuples</label><pre class="src src-ocaml">let rec remove_columns tpl row =
  match row with
  | [] -&gt; []
  | (k, v) :: tl when List.mem k tpl -&gt; (k, v) :: remove_columns tpl tl
  | _ :: tl -&gt; remove_columns tpl tl
</pre>
</div>

<p>
Let&rsquo;s see if the function works on a single row, which is represented by an association list, implemented as a list of tuples <code>(string * string) list</code> (spoiler: it works!)<br>
</p>

<p>
Here&rsquo;s the example of one single row from the <code>table_assoc</code>:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 24: </span>Example – not part of the program code</label><pre class="src src-ocaml">let single_row' = [("a", "1"); ("b", "2"); ("c", "3"); ("d", "4")]
let cleaned_row' = remove_columns template single_row'
</pre>
</div>

<p>
Lets apply this function to all rows of the <code>table_assoc</code>, wich is a list of lists of tuples <code>(string * string) list list</code>. The function <code>remove_columns</code> takes two arguments, but since <a href="http://xahlee.info/UnixResource_dir/writ/currying.html">functions in OCaml are curried by default</a>, they take in fact only one argument, but return a function who takes the second argument, and so on. That&rsquo;s also called <i>partial function application</i>. So we can apply <code>remove_columns</code> to the argument <code>template</code> and map the resulting partial function onto each element of the <code>table_assoc</code><br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 25: </span>Mapping a partial function onto a list of association lists</label><pre class="src src-ocaml">let table_cleaned = List.map (remove_columns template) table_assoc
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org52a265e" class="outline-2">
<h2 id="org52a265e"><a href="#org52a265e">Save the cleaned CSV to Disk</a></h2>
<div class="outline-text-2" id="text-org52a265e">
<p>
How do we get from our data structure, the association list …<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 26: </span>Result – not part of the program code</label><pre class="src src-ocaml">val table_cleaned : (string * string) list list =
                    [[("b", "2"); ("d", "4")];
                     [("b", "6"); ("d", "8")];
                     [("b", "10"); ("d", "12")]]
</pre>
</div>

<p>
… to a CSV file <code>csvcleaner/output.csv</code> like this?<br>
</p>

<pre class="example" id="orgca025b4">
"b"|"d"
"2"|"4"
"6"|"8"
"10"|"12"
</pre>

<p>
Let&rsquo;s check if there is a function in the Csv library that can take the association list <code>table_cleaned</code> and transform it into the CSV file. Here are the <a href="https://math.umons.ac.be/anum/software/csv/Csv/index.html">online docs for the Csv module</a>, by the way. But nope … nothing. Maybe a bit too far off.<br>
</p>

<p>
Ok, then let&rsquo;s see if there is at least a function that will accept a <i>list of lists</i> where each list represents a row? Like we had before where we used <code>Csv.input_all</code> to construct a list of lists from the <code>input_channel</code>?<br>
</p>

<p>
But there is no such one – oh wait! Now I realize that the type <code>Csv.t</code> is just a <i>type synonyme</i> for <code>string list list</code>, and there is in fact a function <code>Csv.save</code> that accepts an argument of the type <code>Csv.t</code>.<br>
</p>

<p>
That means, we have to transform the <i>association list</i> <code>table_cleaned</code> into that kind of simpler list. So we go from this …<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 27: </span>Result – not part of the program code</label><pre class="src src-ocaml">val table_cleaned : (string * string) list list =
                    [[("b", "2"); ("d", "4")];
                     [("b", "6"); ("d", "8")];
                     [("b", "10"); ("d", "12")]]
</pre>
</div>

<p>
… to that:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 28: </span>Result – not part of the program code</label><pre class="src src-ocaml">- : string list list =
[["b"; "d"];
 ["2"; "4"];
 ["6"; "8"];
 ["10"; "12"]]
</pre>
</div>

<p>
We&rsquo;re going to pluck apart the association list <code>table_cleaned</code> and recombine its parts differently. Here&rsquo;s the plan:<br>
</p>

<ol class="org-ol">
<li>We need all column headers to construct the first row of the CSV: so let&rsquo;s extract the <i>keys</i> from the association list and put them in a list.<br></li>
<li>Extract the <i>values</i> for each row and construct one list per row from them.<br></li>
<li>Put all those lists (rows) into another list.<br></li>
</ol>

<p>
I find it quite helpful to <b>start with small functions</b> who work on the <b>innermost structures</b> of the overall data structure. So let&rsquo;s write two little helpers:<br>
</p>

<p>
The 1st helper function <code>get_keys</code> will extract all the keys from one row and collect those keys in a list. It will accept one argument of the type <code>(string * string) list</code>.<br>
</p>

<p>
The 2nd helper function <code>get_values</code> will extract the values from a row and collect them in a list. It will accept also one argument of the type <code>(string * string) list</code>.<br>
</p>

<p>
You may notice there&rsquo;s no formal parameter for the argument we pass to those functions. Why not? We could, but we&rsquo;ll use a short form here. It&rsquo;s only for Functions who accept only one argument <i>and</i> employ pattern matching at the same time.<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let rec get_keys =
  function
  | [] -&gt; []
  | (k, _) :: tl -&gt; k :: get_keys tl

let rec get_values =
  function
  | [] -&gt; []
  | (_, v) :: tl -&gt; v :: get_values tl
</pre>
</div>

<p>
Both functions are &ldquo;list eaters&rdquo;, so they munch the elements of a list one after the other <code>[("b", "2"); ("d", "4")]</code>. Therefore the functions will be <i>recursive</i> – they call themself again and again until they have eaten all the rest elements, and there&rsquo;s nothing left but the empty list. Then they will stop.<br>
</p>

<p>
That&rsquo;s why we define the empty list <code>[]</code> via pattern matching in the first branch as the <i>base case</i>. <code>[] -&gt; []</code> means simply &ldquo;If the argument matches the pattern <i>empty list</i> -&gt; return an <i>empty list</i> (and don&rsquo;t do anything further)&rdquo;.<br>
</p>

<p>
In the 2nd branch of the 1st function <code>get_keys</code> happens quite a lot: On the left side of the arrow we write down the pattern <code>(k, _) :: tl</code>. It reads as follows: &ldquo;From the list of tuples assign the variable <code>k</code> to the 1st element of the first tuple, ignore further elements of the first tuple if there are any. Assign the variable <code>tl</code> to refer to the rest of the list&rdquo;.<br>
</p>

<p>
And the right side says: &ldquo;Put the value bound to <code>k</code> in front of a list and repeat the whole process until nothing is left but an empty list&rdquo;. Mh, that&rsquo;s probably not 100 % exact, but you get the idea.<br>
</p>

<p>
The 2nd function <code>get_values</code> is basically the same, except it cares about the second element of the tuple and assigns the variable <code>v</code> to its value.<br>
</p>

<p>
One more detail: We have to mark functions with the <i>rec</i> keyword to allow them to call themselfes recursively.<br>
</p>

<p>
Now we&rsquo;re putting our helper functions to work as parts of a new function. Let&rsquo;s call that one <code>dissoc</code>. Same here: it takes only one argument and does nothing else than pattern matching on that argument, so we can write it in short form too:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let dissoc =
  function
  | [] -&gt; []
  | hd :: tl -&gt; get_keys hd :: List.map get_values (hd :: tl)
</pre>
</div>

<p>
Here&rsquo;s its type signature. What does it tell?<br>
</p>
<div class="org-src-container">
<pre class="src src-ocaml">val dissoc : ('a * 'a) list list -&gt; 'a list list = &lt;fun&gt;
</pre>
</div>

<p>
Alternatively, we could write that function without pattern matching as well:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 29: </span>Alternative – not part of the program code</label><pre class="src src-ocaml">let dissoc' lst =
  if lst == [] then []
  else get_keys (List.hd lst) :: List.map get_values lst
</pre>
</div>

<p>
Now we can transform the association list into the type expected by the function <code>Csv.save</code>, and we bind the result to the variable <code>table_final</code>:<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let table_final = dissoc table_cleaned
</pre>
</div>

<p>
Finally, we can apply the function <code>Csv.save</code> from the Csv module. The function accepts a few other arguments for convenience (the ones that start with <code>~</code> are <i>labeled arguments</i>):<br>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let () = Csv.save ~separator:'|' ~quote_all:true "output.csv" table_final
</pre>
</div>

<p>
When we apply that function, suddenly a new CSV file <code>csvcleaner/output.csv</code> appears in the project directory!<br>
</p>

<pre class="example" id="org27abf34">
"b"|"d"
"2"|"4"
"6"|"8"
"10"|"12"
</pre>
</div>
</div>
<div id="outline-container-org5575760" class="outline-2">
<h2 id="org5575760"><a href="#org5575760">Conclusion</a></h2>
<div class="outline-text-2" id="text-org5575760">
<p>
<b>Pattern matching is cool</b> because you have a visualization (the pattern) of the data structure you work on right before your eyes, and not just in your head.<br>
</p>

<p>
<b>Type signatures</b> act like a brief unified description of what a function digests and what comes out at the end. That&rsquo;s quite elegant and helpful in most cases. It becomes unhelpful when a library author omits further explanations and examples.<br>
</p>

<p>
<b>Finding sensible names</b> for functions and variables all the time sucks. More so, if type signatures and function definitions already say all there is to say. That means for me:<br>
</p>
<ul class="org-ul">
<li>always consider whether a global definition is really necessary<br></li>
<li>keep small functions anonymous where possible<br></li>
<li>avoid formal parameters when they don&rsquo;t contribute to clarity<br></li>
</ul>

<p>
<b>Partial function application</b> (via curried functions) seems to be cool too. But to think in terms of chaining partial functions while reasoning about how to express a particular thing in code doesn&rsquo;t come naturally yet. Partial application can make code also more difficult to understand: Look at the following definition of the wrapper function <code>save</code>. Is it clear that it actually takes another argument, namely the output file name?<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 30: </span>Example – not part of the program code</label><pre class="src src-ocaml">let save tab =
  Csv.save ~separator:'|' ~quote_all:true tab
</pre>
</div>

<p>
One has to look at the type signature first to realize that the function can take one more argument, an innocent <i>string</i> which is the file name:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 31: </span>Type signature – not part of the program code</label><pre class="src src-ocaml">val save : string -&gt; Csv.t -&gt; unit = &lt;fun&gt;
</pre>
</div>

<p>
That argument comes from the inner function <code>Csv.save</code> which takes the file name as a string:<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 32: </span>Type signature – not part of the program code</label><pre class="src src-ocaml">- : ?separator:char -&gt;
    ?backslash_escape:bool -&gt;
    ?excel_tricks:bool -&gt; ?quote_all:bool -&gt; string -&gt; Csv.t -&gt; unit
= &lt;fun&gt;
</pre>
</div>
</div>
<div id="outline-container-orgcb98e15" class="outline-3">
<h3 id="orgcb98e15"><a href="#orgcb98e15">Full Code Listing</a></h3>
<div class="outline-text-3" id="text-orgcb98e15">
<p>
The separation of the program comes quite naturally: input - preparation - work - preparation - output. My code is not so elegant: Many many top-level definitions and variables who carry the intermediary results for the next steps.<br>
</p>

<p>
Is there a better structure for this program? Maybe kinda like a pipe where you can plug in other functions in between – like layers of filters. That would make it easy to add new features in the future. I couldn&rsquo;t wait to refactor it that way, so I&rsquo;m adding version 0.2 below. But first, here&rsquo;s the whole spaghetti pot we cooked up so far:<br>
</p>
</div>
<div id="outline-container-org61611bc" class="outline-4">
<h4 id="org61611bc"><a href="#org61611bc">Version 0.1</a></h4>
<div class="outline-text-4" id="text-org61611bc">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 33: </span>The Spaghetti Monster</label><pre class="src src-ocaml">(* Version 0.1 *)

(* Transforms the file into a key-value data structure *)

let csv_file = open_in "input.csv"
let table = Csv.input_all (Csv.of_channel csv_file)
let () = close_in csv_file

let header, content =
  match table with
  | [] -&gt; assert false
  | hd :: tl -&gt; hd, tl

let table_assoc = Csv.associate header content


(* Drops the columns that are not specified by the template *)

let template_file = open_in "template.csv"
let template = Csv.Rows.header (Csv.of_channel ~has_header:true template_file)
let () = close_in template_file

let rec remove_columns tpl row =
  match row with
  | [] -&gt; []
  | (k, v) :: tl when List.mem k tpl -&gt; (k, v) :: remove_columns tpl tl
  | _ :: tl -&gt; remove_columns tpl tl

let table_cleaned = List.map (remove_columns template) table_assoc


(* Transforms the key-value data structure into lists representing lines *)

let rec get_keys =
  function
  | [] -&gt; []
  | (k, _) :: tl -&gt; k :: get_keys tl

let rec get_values =
  function
  | [] -&gt; []
  | (_, v) :: tl -&gt; v :: get_values tl

let dissoc =
  function
  | [] -&gt; []
  | hd :: tl -&gt; get_keys hd :: List.map get_values (hd :: tl)

let table_final = dissoc table_cleaned


(* Writes the cleaned CSV file to disk *)

let () = Csv.save ~separator:'|' ~quote_all:true "output.csv" table_final
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcef6da3" class="outline-4">
<h4 id="orgcef6da3"><a href="#orgcef6da3">Version 0.2</a></h4>
<div class="outline-text-4" id="text-orgcef6da3">
<p>
And here comes the code after refactoring. The version 0.2 hasn&rsquo;t got any shorter and the single functions got a bit more complex, but overall it got clearer than version 0.1.<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 34: </span>The Pipe</label><pre class="src src-ocaml">(* Version 0.2 *)

(** Transforms the file into a key-value data structure *)
let prep file =
  let tab_file = open_in file in
  tab_file
  |&gt; Csv.of_channel
  |&gt; Csv.input_all
  |&gt; fun tab -&gt; let head, body =
                  match tab with
                  | [] -&gt; assert false
                  | hd :: tl -&gt; hd, tl in
  let () = close_in tab_file in
  Csv.associate head body


(** Drops the columns that are not specified by the template *)
let clean tab =
  let tpl_file = open_in "template.csv" in
  let tpl = tpl_file
            |&gt; Csv.of_channel ~has_header:true
            |&gt; Csv.Rows.header in
  let () = close_in tpl_file in
  let rec remove_cols tpl row =
    match row with
    | [] -&gt; []
    | (k, v) :: tl when List.mem k tpl -&gt; (k, v) :: remove_cols tpl tl
    | _ :: tl -&gt; remove_cols tpl tl in
  List.map (remove_cols tpl) tab


(** Transforms the key-value data structure into lists representing lines *)
let dissoc =
  let rec get_keys =
    function
    | [] -&gt; []
    | (k, _) :: tl -&gt; k :: get_keys tl in
  let rec get_values =
    function
    | [] -&gt; []
    | (_, v) :: tl -&gt; v :: get_values tl in
  function
  | [] -&gt; []
  | hd :: tl -&gt; get_keys hd :: List.map get_values (hd :: tl)


(** Writes the cleaned CSV file to disk *)
let save tab =
  Csv.save ~separator:'|' ~quote_all:true tab


(** Puts all together in one pipe *)
let () = "input.csv"
         |&gt; prep
         |&gt; clean
         |&gt; dissoc
         |&gt; save "output.csv"
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org1cc37a7" class="outline-2">
<h2 id="org1cc37a7"><a href="#org1cc37a7">Compile the Standalone Binary Executable</a></h2>
<div class="outline-text-2" id="text-org1cc37a7">
<ul class="org-ul">
<li><b>Compile only:</b> Change into your project directory <code>cd csvcleaner/</code> and issue the command <code>dune build</code>. Your compiled binary will be <code>csvcleaner/_build/default/csvcleaner.exe</code>. Don&rsquo;t get confused about the <i>.exe</i> suffix — it&rsquo;s just a naming convention in dune, not a windows binary if you compile on Linux.<br></li>

<li><b>Compile and run</b> the executable: <code>dune exec ./csvcleaner.exe</code><br></li>
</ul>

<p>
If you are looking for a versatile tool to work on CSV files, check out <i>csvtool</i>. It is a command line utility written in OCaml by the creator of the Csv library I&rsquo;m using here, and it is available via Opam <code>opam install csvtool</code> or as a package in Ubuntu: <code>apt install csvtool</code> and probably other Linux distros.<br>
</p>
</div>
</div>
<div id="outline-container-org0be8dff" class="outline-2">
<h2 id="org0be8dff"><a href="#org0be8dff">What&rsquo;s next?</a></h2>
<div class="outline-text-2" id="text-org0be8dff">
<p>
In the <a href="first-coding-project-ocaml-tail-recursion-episode-3.tutorial.html">next episode</a> I&rsquo;m probably going to rewrite this again in Common Lisp using pattern matching, add a feature to version 0.2, or do something else entirely. Please let me know if you enjoyed the walktrough. Thank you for reading!<br>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<div class="footer">Published by <span class="author"><a href="/bio.html">Dan Dee</a></span></div>
<script defer src="/static/footer.js"></script>
</div>
</body>
</html>
